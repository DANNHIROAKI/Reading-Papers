### $\textbf{Indexing for Keyword Search with Structured Constraints}$ 

# $\textbf{0. Abstract}$ 

> :one:关键词查询
>
> 1. 含义：用户提供关键词$\to$查找文档中所有相同的关键词
> 2. 特点：查询对象不符合任何预设模式(非结构化)
>
> :two:空间关键词搜索
>
> 1. 含义：关键词索引$+$预定属性上的结构性谓词
>
>    - 预订属性$=$​空间信息(地理/文本)
>    - 结构性谓词分为：范围条件/线性约束/距离优先排序
>
> 2. 示例：
>
>    | 关键词 |  属性的谓词类型  |         属性的谓词         | 示例                                 |
>    | :----: | :--------------: | :------------------------: | ------------------------------------ |
>    | 咖啡厅 |     范围条件     |       $5$公里范围内        | 找到$5$公里范围内的咖啡厅            |
>    | 咖啡厅 |     线性约束     | 价钱在$10\$\text{-}20\$$的 | 找到价钱在$10\$\text{-}20\$$的咖啡厅 |
>    | 咖啡厅 | 按距离优先级排序 |      按照离家距离排序      | 找到离家最近的几家咖啡厅             |
>
> 3. 研究现状：最先进方法任然是基于关键词$+$​结构性谓词的朴素查询方法
>
> :three:本文工作：
>
> 1. 要做啥：为实际中意义重大的问题，开发具有强理论保证的新索引
> 2. 做咋样：在广泛接受的猜想前提下，非常接近最优解

# $\textbf{1. Introduction}$ 

> ## $\textbf{1.0. Intro}$ 
>
> > :one:两种查询方式
> >
> > 1. 结构化查询：查询谓词需要符合预设的模式
> > 2. 非结构化查询：比如文本的关键字查询
> >
> > :two:两种查询的示例：对于`Hotel`关系
> >
> > ```sql
> > Hotel(price, rating, Doc) -- 价格/评分/文本标签
> > ```
> >
> > 1. 结构化查询：检索==满足结构化条件==的对象
> >    - $\mathbf{C 1}$ 单独约束的结构化条件：`price`$\in[\$100, \$200]$且 `rating`$\geq 8$
> >    - $\mathbf{C 2}$ 联合约束的结构化条件：$c_1\cdot$`price`$+c_2 \cdot(10-$`rating`$) \leq c_3$
> > 2. 关键词查询：检索文档中==包含了关键词==的对象，比如`Doc`种包含`pool/free-parking....` 
> >
> > :three:研究现状
> >
> > 1. 单独适用结构/关键字查询的弊端：需要检查大量对象，查询时间渐进等于读取所有数据
> > 2. 融合结构化$+$​关键词查询的研究难点：很多这样的索引在实际数据上表现良好，但理论进展很少
> > 3. 本文要做的：
> >    - 提出了新的索引方法，优化了结构化$+$关键词融合的查询
> >    - 给出了各种情况的复杂度$\text{(hardness results)}$​ 
>
> ## $\textbf{1.1. New Indexing Results}$ 
>
> > ### $\textbf{1.1.0. Intro}$ 
> >
> > > :one:一些记号
> > >
> > > 1. 输入与对象：所有问题的输入数据集都记作$D$，集合$D$中的元素$e\in{}D$​称为对象
> > > 2. 对象的文档：$\forall{}e\in{}D$关联一个非空文档(且全由数字构成)，记作$e.$​`Doc`  
> > > 3. 关键词：记作$\mathrm{w}_1, \mathrm{w}_2, \ldots \mathrm{w}_k$
> > >
> > > :two:一些定义：注意符号$:=$是定义为的意思
> > >
> > > 1. 输入大小：$N:=\displaystyle{}\sum_{e \in D} \mid e . $`Doc`$\mid$即所有对象的文档的总大小
> > > 2. 包含关键词$\mathrm{w}_1, \ldots, \mathrm{w}_k$的对象集：即$D\left(\mathrm{w}_1, \ldots, \mathrm{w}_k\right):=\{e \in D \mid \forall i \in[1, k]有\mathrm{w}_i \in e . $`Doc`$\}$ 
> > >
> > > :three:一些假设
> > >
> > > 1. 输入数据需要$\Theta(N)$个字来存储，其中每个字至少有$\log_2 N\text{ bit}$ 
> > > 2. 计算模型为标准$\text{RAM}$​模型，即计算直接访问内存，且读写都在常数时间内完成
> >
> > ### $\textbf{1.1.1. Range Reporting with Keywords}$ 
> >
> > > #### $\textbf{1.1.1.1. Orthogonal Range Reporting with Keywords (ORP-KW)}$ 
> > >
> > > > :one:$\text{ORP-KW}$​：正交范围报告$+$关键词搜索，例如示例中的$\mathbf{C 1}$
> > > >
> > > > 1. 基本要素：$D$为$\mathbb{R}^d$中一组点，查询返回的为点$e\in{}D$，且该点的文档记为$e.$`Doc` 
> > > > 2. 查询操作：
> > > >    - 给定：$d$-矩形($d$维空间中的矩形)$q$，还有关键词$\mathrm{w}_1, \mathrm{w}_2, \ldots, \mathrm{w}_k$。矩形结构是正交所在
> > > >    - 返回：$q \cap D\left(\mathrm{w}_1, \ldots, \mathrm{w}_k\right)$，即$e$落在$q$内$+$$e.$`Doc`包含所有关键词
> > > > 3. 简而言之就是：返回对象$e$的属性值$\in{}[C_1,C_2]+$ $e.$`Doc`包括所有关键词
> > > >
> > > > :two:定理：$N$是输入大小，$k$是关键词的数量，$\text{OUT}$是查询结果数量(报告点的数量)
> > > >
> > > > 1. ==定理$1$==：维度$d \leq 2$情况下，复杂度$\to{}\begin{cases}索引空间\text{: }O(N)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{k}}\cdot\left(1+\text{OUT}^{\cfrac{1}{k}}\right)\right)\end{cases}$​ 
> > > > 2. ==定理$2$==：维度$d \geq 3$情况下，复杂度$\to{}\begin{cases}索引空间\text{: }O\left(N \cdot(\log \log N)^{d-2}\right)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{k}}\cdot\left(1+\text{OUT}^{\cfrac{1}{k}}\right)\right)\end{cases}$​  
> > > >    - $d>3$时，索引空间当$d$每$\text{+1}$就增加$O(\log \log N)$​，查询时间不变
> > >
> > > #### $\textbf{1.1.1.2. Rectangle Reporting with Keywords (RR-KW)}$ 
> > >
> > > > :one:$\text{RR-KW}$​：区间报告$+$关键词搜索
> > > >
> > > > 1. 基本要素：$D$为$\mathbb{R}^d$中一组$d$-矩形，查询返回的为矩形$e\in{}D$，且该矩形文档记为$e.$`Doc` 
> > > > 2. 查询操作：
> > > >    - 给定：$d$-矩形$q$，还有关键词$\mathrm{w}_1, \mathrm{w}_2, \ldots, \mathrm{w}_k$ 
> > > >    - 返回：矩形$e$与$q$有交叉$+$矩形$e.$​`Doc`包含所有关键词
> > > >
> > > > :two:特殊的$\text{RR-KW}$
> > > >
> > > > 1. 时间文档$+$关键词搜索：
> > > >    - 情形：$\text{RR-KW}$中$d=1$​ 
> > > >    - 原理：矩形为一维(线段)用来表示时间区间，或者说文档的生命周期
> > > > 2. 地理实体$+$关键词搜索：
> > > >    - 情形：$\text{RR-KW}$中$d=2$​  
> > > >    - 原理：矩形为二维(平面)用来表示地理区域，文档用于描述该区域
> > > >
> > > > :three:基于定理$1,2$的==推论$3$==：复杂度$\to{}\begin{cases}索引空间\text{: }O\left(N \cdot(\log \log N)^{2d-2}\right)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{k}}\cdot\left(1+\text{OUT}^{\cfrac{1}{k}}\right)\right)\end{cases}$  
> > > >
> > > > - $N$是输入大小，$k$是关键词的数量，$\text{OUT}$是查询结果数量(报告矩形的数量) 
> > >
> > > #### $\textbf{1.1.1.3. }L_{\infin}\text{-}\textbf{Nearest Neighbor with Keywords}\textbf{(}L_{\infin}\textbf{NN-KW)}$
> > >
> > > > :zero:$L_{\infin}$​距离：即切比雪夫距离，即多维空间中两点坐标差的最大值
> > > >
> > > > - $\begin{cases}\vec{p}= (p_1, p_2, \ldots, p_d)\\\\\vec{q} = (q_1, q_2, \ldots, q_d)\end{cases}\implies{}L_{\infty}(p, q)=\max _{i=1, \ldots, d}\left|p_i-q_i\right|$ 
> > > >
> > > > :one:$L_{\infin}\text{NN-KW}$：$L_{\infin}$最邻近$+$关键词搜索，本质上是带有关键词的相似性搜索
> > > >
> > > > 1. 基本要素：$D$为$\mathbb{R}^d$中一组点，查询返回的为对象$e\in{}D$，且该点文档记为$e.$`Doc` 
> > > > 2. 查询操作：
> > > >    - 给定：$\mathbb{R}^d$中的一个点 $q$，还有关键词$\mathrm{w}_1, \mathrm{w}_2, \ldots, \mathrm{w}_k$ 
> > > >    - 返回：$D\left(\mathrm{w}_1, \ldots, \mathrm{w}_{k}\right)$中与$q$最近前的$t$个点，距离是指$L_{\infin}$​距离
> > > >
> > > > :two:基于定理$1,2$的==推论$4$==：复杂度$\to{}\begin{cases}索引空间\text{: }O\left(N \cdot(\log \log N)^{d-2}\right)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{k}}\cdot{}t^{\cfrac{1}{k}}\cdot\log{}N\right)\end{cases}$​ 
> > > >
> > > > 1. 符号：$N$是输入大小，$k$是关键词的数量，$t$是查询结果数量(前$t$​​个点) 
> > > > 2. $\text{Ps. }$以上结果也是在$L_2$距离(欧几里得距离)上的近似情况
> > > >
> > > > :three:示例：检索具有`pool`关键词的若干家酒店，并按离我的距离进行排序
> >
> > ### $\textbf{1.1.2. Linear Conjunction with Keywords }$  
> >
> > > #### $\textbf{1.1.2.1. Linear Conjunction with Keywords (LC-KW)}$  
> > >
> > > > :zero:线性约束：
> > > >
> > > > 1. 基本元素：给定一组实数$c_1, c_2, \ldots, c_{d+1}$，给定一个点$p:=(p[1], \ldots, p[d])$ 
> > > > 2. $p$受到线性约束${}\xLeftrightarrow{}\displaystyle{}\sum_{i=1}^d c_i \cdot p[i] \leq c_{d+1}$ 
> > > >
> > > > :one:$\text{LC-KW}$：线性联接$+$关键词搜索，例如实例中的$\mathbf{C2}$ 
> > > >
> > > > 1. 基本要素：$D$为$\mathbb{R}^d$中一组点，查询返回的为对象$p\in{}D$，且该点的文档记为$p.$`Doc` 
> > > > 2. 查询操作：
> > > >    - 给定：$s = O(1)$个线性约束，还有关键词$\mathrm{w}_1, \mathrm{w}_2, \ldots, \mathrm{w}_k$ 
> > > >    - 返回：$p$满足所有$s$个线性约束$+$$p.$`Doc`包含所有关键词
> > > >
> > > > :two:==定理$5$==：复杂度$\to\begin{cases}d\leq{}k\to{}\begin{cases}索引空间\text{: }O(N)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{k}}\cdot\left(\log{}N+\text{OUT}^{\cfrac{1}{k}}\right)\right)\end{cases}\\\\d>k\to{}\begin{cases}索引空间\text{: }O(N)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{d}}+N^{1-\cfrac{1}{k}}\cdot\text{OUT}^{\cfrac{1}{k}}\right)\end{cases}\end{cases}$​ 
> > > >
> > > > - $N$​是输入大小，$k$​是关键词的数量，$\text{OUT}$​是查询结果数量 
> > > >
> > > > :three:分析：
> > > >
> > > > 1. $\text{ORP-KW}$问题中的$d$维矩形，相当于$\text{LC-KW}$中$2d$​个线性约束
> > > > 2. 本质上是$d$维中每维有上下两个界($1$界${}=1$约束)；比如二维矩形的$x$上下界和$y$上下界
> > >
> > > #### $\textbf{1.1.2.2. Spherical Range Reporting with Keywords (SRP-KW)}$   
> > >
> > > > :one:$\text{SRP-KW}$：球状区间报告$+$关键词搜索，$\text{aka}$带关键词的布尔范围查询
> > > >
> > > > 1. 基本要素：$D$为$\mathbb{R}^d$中一组点，查询返回的为对象$e\in{}D$，且该点的文档记为$e.$`Doc` 
> > > > 2. 查询操作：
> > > >    - 给定：一个$d$维空间的球体$q$，还有关键词$\mathrm{w}_1, \mathrm{w}_2, \ldots, \mathrm{w}_k$​ 
> > > >    - 返回：$e$要在球体$q$内$+$$e.$`Doc`包含所有关键词，即$q \cap D\left(\mathrm{w}_1, \ldots, \mathrm{w}_k\right)$​ 
> > > >
> > > > :two:示例：找到距离给定地址$1$公里内且包含关键词 $\mathrm{w}_1, \ldots, \mathrm{w}_k$​​ 的所有酒店
> > > >
> > > > :three:定理$5$的==推论$6$==：复杂度$\to\begin{cases}d\leq{}k-1\to{}\begin{cases}索引空间\text{: }O(N)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{k}}\cdot\left(\log{}N+\text{OUT}^{\cfrac{1}{k}}\right)\right)\end{cases}\\\\d>k-1\to{}\begin{cases}索引空间\text{: }O(N)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{d}}+N^{1-\cfrac{1}{k}}\cdot\text{OUT}^{\cfrac{1}{k}}\right)\end{cases}\end{cases}$​ 
> > > >
> > > > - $N$是输入大小，$k$是关键词的数量，$\text{OUT}$​是查询结果数量 
> > >
> > > #### $\textbf{1.1.2.3. }L_2\textbf{ Nearest Neighbor    with Keywords (SRP-KW)}$​   
> > >
> > > > :one:$L_2\text{ NN-KW}$：$L_2$邻近$+$关键词搜索
> > > >
> > > > 1. 基本要素：$D$为$\mathbb{N}^d$中一组点，查询返回的为对象$e\in{}D$，且该点文档记为$e.$`Doc` 
> > > >    - 注意$\mathbb{N}$是$O(\log{}N)\text{-bits}$整数集合，即整数集$\mathbb{N}$的最大值${}\propto{}\log{}N$ 
> > > > 2. 查询操作：
> > > >    - 给定：$q\in{}\mathbb{N}^d$，还有关键词$\mathrm{w}_1, \mathrm{w}_2, \ldots, \mathrm{w}_k$ 
> > > >    - 返回：$D\left(\mathrm{w}_1, \ldots, \mathrm{w}_{k}\right)$中与$q$最近前的$t$个点，距离是指$L_{2}$距离 
> > > >
> > > > :two:推论$6$的==推论$7$==$\to\begin{cases}d\leq{}k-1\to{}\begin{cases}索引空间\text{: }O(N)\\\\查询时间\text{: }O\left(\log{}N\cdot{}N^{1-\cfrac{1}{k}}\cdot\left(\log{}N+t^{\cfrac{1}{k}}\right)\right)\end{cases}\\\\d>k-1\to{}\begin{cases}索引空间\text{: }O(N)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{d+1}}+N^{1-\cfrac{1}{k}}\cdot{}t^{\cfrac{1}{k}}\right)\end{cases}\end{cases}$​   
> > > >
> > > > - $N$是输入大小，$k$是关键词的数量，$t$是查询结果数量(前$t$​个点) 
>
> ## $\textbf{1.1. Tightness of Our Results}$   
>
> > :dagger:紧性：指复杂度界限的精确度，复杂度具有紧性表示其上下界统一
> >
> > ### $\textbf{1.1.1. }k\textbf{-Set Intersection }(k\textbf{-SI})$​  
> >
> > > :one:$k$​-集合交集：
> > >
> > > 1. 输入：$m$个整数集合，记作$S_1, S_2, \ldots, S_m$ 
> > > 2. 报告查询($\text{reporting query}$)
> > >    - 操作：从$[1,m]$中选取$k=O(1)$个整数，记作$\mathrm{w}_1, \mathrm{w}_2, \ldots, \mathrm{w}_k$ 
> > >    - 返回：$\displaystyle{}\bigcap_{i=1}^k S_{\mathrm{w}_i}$​ 
> > > 3. 空查询($\text{emptiness query}$)：操作一样，但是只返回$\displaystyle{}\bigcap_{i=1}^k S_{\mathrm{w}_i}$​为空与否
> > >
> > > :two:纯粹关键词查询$\xleftrightarrow{等价于}k\text{-SI}$​报告查询
> > >
> > > 1. 正向等价：倒排索引($\text{Inverted Index}$)
> > >    - ==为每个关键词$\mathrm{w}$创建集合$S_{\mathrm{w}}$==，其中$e\in{}S_{\mathrm{w}}\xrightarrow{对应}e.$`Doc`包含关键词$\mathrm{w}$   
> > >    - 由此$\displaystyle{}D\left(\mathrm{w}_1, \ldots, \mathrm{w}_k\right)\xRightarrow{}\bigcap_{i=1}^k S_{\mathrm{w}_i}$​   
> > > 2. 反向等价：给定一个$k\text{-SI}$实例$\xrightarrow{创建}$​关键词搜索实例
> > >    - ==为每个对象$e\in{}\displaystyle{}D=\bigcup_{i=1}^m S_i$创建文档$e.$`Doc`==，其中$e.$`Doc` $:=\left\{i \mid e \in S_i\right\}$
> > >      - 如$S_1S_3$包含$e$则$e.$`Doc`$\text{=\{1,3\}}$ 
> > >    - 由此$\displaystyle{}\displaystyle{}D\left(\mathrm{w}_1, \ldots, \mathrm{w}_k\right)\xLeftarrow{}\bigcap_{i=1}^k S_{\mathrm{w}_i}$​   
> > >
> > > :three:关于$k\text{-SI}$​​被广泛验证的两个猜想
> > >
> > > 0. 写在前面
> > >    - 值得注意的一个符号：$ \text{polylog}(N) = (\log N)^k$ 
> > >    - 要素：$\displaystyle{}N:=\sum_{i=1}^m\left|S_i\right|$，$\text{OUT}$​​是报告的交集的大小
> > >
> > > 1. 强集合相交猜想$\text{(Strong set-intersection conjectur)}$
> > >    - $\delta \in(0,1]$ 
> > >    - $k\text{-SI}$报告查询：$查询时间\text{: }O\left(N^{1-\delta}+\text{OUT}\right)\xrightarrow{必须使用}索引空间\text{: }\Omega\left(\cfrac{N^{1+\delta}}{\text{polylog }N}\right)$  
> > > 2.  强$k\text{-}$集合不相交猜想$\text{(Strong k-set-disjointness   conjectur)}$ 
> > >    - $\delta \in(0,1-\cfrac{1}{k}]$  
> > >    - $k\text{-SI}$报告查询：$查询时间\text{: }O\left(N^{1-\cfrac{1}{k}-\delta}\right)\xrightarrow{必须使用}索引空间\text{: }\Omega\left(\cfrac{N^{1+k\delta}}{\text{polylog }N}\right)$   
> >
> > ### $\textbf{1.1.2. }k\textbf{-SI Complexity}$ 
> >
> > > :one:==引理$8$==：对于$k\text{-SI}$报告查询
> > >
> > > 1. 前提：存在一个索引结构$\to{}\begin{cases}索引空间\text{: }O\left(N\cdot\text{polylog }N\right)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{k}}+N^{1-\cfrac{1}{k}} \cdot \text { OUT }^{\cfrac{1}{k}-\epsilon}+\mathrm{OUT}\right)\end{cases}$  
> > > 2. 结论：
> > >    - 该索引也能在$O\left(N^{1-\delta}+\mathrm{OUT}\right)$时间内完成，其中$\delta=\min \left\{\cfrac{1}{k}, \cfrac{\epsilon}{1-\frac{1}{k}+\epsilon}\right\}$   
> > >    - 这违反了强集合相交猜想
> > >
> > > :two:对于满足$\to{}\begin{cases}索引空间\text{: }O\left(N\cdot\text{polylog }N\right)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{k}}\cdot \left(1+\text { OUT }^{\cfrac{1}{k}}\right)\right)\end{cases}$的$k\text{-SI}$报告查询的分析
> > >
> > > 1. 多项式($\text{polynominal}$)含义：查询$+$输出复杂度$O\left(N^{1-\cfrac{1}{k}}+N^{1-\cfrac{1}{k}}\cdot\text { OUT }^{\cfrac{1}{k}}+\text{OUT}\right)$​  
> > >
> > >    |                            多项式                            | 操作                       |
> > >    | :----------------------------------------------------------: | -------------------------- |
> > >    |              $O\left(N^{1-\cfrac{1}{k}}\right)$              | 读取输入数据并进行初步处理 |
> > >    | $O\left(N^{1-\cfrac{1}{k}}\right)\cdot\text { OUT }^{\cfrac{1}{k}}$ | 对输出结果的进行终处理     |
> > >    |                  $O\left(\text{OUT}\right)$                  | 输出操作                   |
> > >
> > > 2. 多项式因子紧性(接近最优)分析
> > >
> > >    - $O\left(N^{1-\cfrac{1}{k}}\right)$为最优：
> > >      - 假设：存在更优解$O\left(N^{1-\cfrac{1}{k}-\epsilon}\right)$，$k\text{-SI}$报告查询在$\text{OUT}$为空时最快$O\left(N^{1-\cfrac{1}{k}-\epsilon}\right)$  
> > >      - $k\text{-SI}$空查询时间：就是$O\left(N^{1-\cfrac{1}{k}-\epsilon}\right)$​，因为超出这个时间就必定非空，立马终止算法
> > >      - 假设违反了强集合相交猜想，假设不成立
> > >    - $O\left(N^{1-\cfrac{1}{k}}\right)\cdot\text { OUT }^{\cfrac{1}{k}}$ 为最优：否就违反了引理$8$
> > >    - $O\left(\text{OUT}\right)$最优：输出是不可能不输出的
> >
> > ### $\textbf{1.1.3. To Sum Up}$ 
> >
> > > :one:所有的$\text{ORP-KW/RR-KW/LC-KW}$本质上都是$k\text{-SI}$报告查询的泛化
> > >
> > > :two:$k\text{-SI}$查询$\xrightarrow{给定索引空间}O\left(N\cdot\text{polylog }N\right)\xrightarrow{最优查询时间}O\left(N^{1-\cfrac{1}{k}}\left(1+\text { OUT }^{\cfrac{1}{k}}\right)+\text{OUT}\right)$​  
> > >
> > > - 值得注意：随着$k$增加时间复杂度接近$O(N)$即朴素解，所以不能让$k$太大
> > >
> > > :three:结合$1/2$可证明：
> > >
> > > 1. 定理$1/$定理$2/$推论$3$最优
> > > 2. $d\leq{}k$时定理$5$最优，$d+1\leq{}k$时推论$6$最优
> > > 3. 推论$4/$推论$7$在一定情况下最优

# $\textbf{2. Previous Works}$​ 

> ## $\textbf{2.1. }k\text{-SI}$报告查询 
>
> > :one:核心的研究问题：
> >
> > 1. 基石：利用完美哈希，可以实现$k\text{-SI}$报告查询复杂度$\to{}\begin{cases}索引空间\text{: }O(N)\\\\查询时间\text{: }O(N)\end{cases}$ 
> >    - 哈希冲突：不同键被哈希至一个桶内，例如$\text{15\%10=25\%10=5}$，$15/25$就冲突了
> >    - 完美哈希：避免了所有哈希冲突的特殊哈希
> > 2. 改良方向：在索引空间任然是$O(N)$的情况下，降低查询时间
> >
> > :two:方向一：实现$o(N)+O(\text{OUT})$的查询时间，$o(N)$是比$O(N)$更严格上界(最坏情况比线性时间小得多)
> >
> > |            $k\text{-SI}$报告查询文献             |                           查询时间                           |   $\textbf{wlen}$字长限制    | $k$限制 |
> > | :----------------------------------------------: | :----------------------------------------------------------: | :--------------------------: | :-----: |
> > | [[1]](https://doi.org/10.48550/arXiv.0708.3259)  | $O\left(\cfrac{N(\log \text{wlen})^2}{\text{wlen}}  + \text{OUT}\right)$ |             $/$              |   $/$   |
> > |  [[2]](https://doi.org/10.1145/3034786.3056115)  | $O\left(\cfrac{N(\log \text{wlen})}{\text{wlen}}  + \text{OUT}\right)$ |             $/$              |  $k=2$  |
> > | [[3]](https://doi.org/10.48550/arXiv.1708.09059) | $O\left(\cfrac{N(\log \text{wlen})}{\text{wlen}}  + \text{OUT}\right)$ |             $/$              |   $/$   |
> > | [[3]](https://doi.org/10.48550/arXiv.1708.09059) |  $O\left(\cfrac{N(\log \log N)}{\log N}+ \text{OUT}\right)$  | $\text{wlen}=\Theta(\log N)$ |   $/$   |
> >
> > :two:当$\text{OUT}$极小时，实现较朴素方法的改进
> >
> > 1. [文献](https://doi.org/10.48550/arXiv.1709.06186) 
> >
> >    | $k$限制 |       $\textbf{OUT}$限制        | 索引空间 |              查询时间              |
> >    | :-----: | :-----------------------------: | :------: | :--------------------------------: |
> >    |  $k=2$  |               $/$               |  $O(N)$  | $O(\sqrt{N}(1+\sqrt{\text{OUT}}))$ |
> >    |  $k=2$  |     $\text{OUT}=\Omega(N)$      |  $O(N)$  |               $O(N)$               |
> >    |  $k=2$  |        $\text{OUT}=o(N)$        |  $O(N)$  |               $o(N)$               |
> >    |  $k=2$  | $\text{OUT}\leq N^{1-\epsilon}$ |  $O(N)$  |       $O(N^{1 - \epsilon})$        |
> >
> > 2. [文献](https://doi.org/10.48550/arXiv.1604.06264) 
> >
> >    | $k$限制 | $\textbf{OUT}$限制  |                           查询时间                           |         达到查询时间所需的索引空间          |
> >    | :-----: | :-----------------: | :----------------------------------------------------------: | :-----------------------------------------: |
> >    |  $k=2$  |         $/$         |          $O\left(N^{1-\epsilon}+\text{OUT}\right)$           |  $\Omega\left(N^{1+\epsilon-o(1)}\right)$   |
> >    |  $k=2$  | $\text{OUT}\geq{}1$ | $O\left((N \cdot \text{OUT})^{\frac{1}{2}-\epsilon}+\text{OUT}\right)$ | $\Omega\left(N^{1+f(\epsilon)-o(1)}\right)$ |
>
> ## $\textbf{2.2. }$研究目的
>
> > :one:目的：在结构化约束前提下，仍能在$O\left(N^{1-\cfrac{1}{k}}{} \cdot\left(1+\mathrm{OUT}^{\cfrac{1}{k}}\right)\right)$查询时间内实现关键词搜索
> >
> > :two:[有关工作](https://doi.org/10.48550/arXiv.1708.09059)：一维$\text{ORP-KW}$且$\text{wlen}=O(\log N)$时$\to{}\begin{cases}索引空间\text{: }O\left(N\right)\\\\查询时间\text{: }O\left(\cfrac{N(\log \log N)}{\log N}+ \text{OUT}\right)\end{cases}$ 

# $\textbf{3. Index Transformation Framework}$ 

> ## $\textbf{3.1. Intro}$ 
>
> > :one:背景：
> >
> > 1. 对于没有关键词的纯粹结构化查询，其有效索引($\text{aka}$纯几何索引)都已经被充分研究
> > 2. 对支持关键词查询的结构化查询，可以将纯几何索引转化为支持关键词查询的索引
> >
> > :two:本文干了啥：设计了一个通用框架，实现对一类几何索引的转换
> >
> > 1. 通用框架：通过调整二维$kd\text{-}$树
> > 2. 以$\text{ORP-KW}$为例展示转换过程
>
> ## $\textbf{3.1. Identifying a Space-Partitioning Index}$ 
>
> > :one:$kd\text{-}$树的定义
> >
> > 1. $P\in{}\mathbb{R}^2$且$|P|=N$，记作$P=\{X_1,X_2,...,X_N\}$ 
> > 2. 二叉树$\mathcal{T}$是$kd\text{-}$树$\xLeftrightarrow{}\begin{cases}叶结点\text{: }共N个且与X_1\to{}X_N逐一对应\\\\内部结点\text{: }必定含有两子节点\end{cases}$  
> >
> > :two:一些符号
> >
> > |       符号        | 含义                                                         |
> > | :---------------: | ------------------------------------------------------------ |
> > |       $P_u$       | 以$kd\text{-}$树中间节点$u$为根的子树的叶节点集，所对应的$\mathbb{R}^2$中的点集 |
> > |    $\Delta_u$     | $\mathbb{R}^2$中包住$P_u$所有点的矩形，矩形长宽平行于坐标    |
> > | $\text{level}(u)$ | $u$所在的层数，默认根结点在$0$层                             |
> >
> > - 显然$\forall{}u\in{}\mathcal{T}$存在$\left|P_u\right|=O\left(\cfrac{N}{2^{\text{level } (u)}}\right)$ 
> >
> > :three:空间分割操作
> >
> > | $\text{level}(u)$ |                     $kd\text{-}$树(部分)                     |                       $\Delta_u$的分割                       |
> > | :---------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
> > |       偶数        | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240808191618577.png" alt="image-20240808191618577" style="zoom:43%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240808192010678.png" alt="image-20240808192010678" style="zoom:33%;" /> |
> > |       奇数        | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240808191620383.png" alt="image-20240808191620383" style="zoom:43%;" /> | <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240808192027223.png" alt="image-20240808192027223" style="zoom:33%;" /> |
>
> ## $\textbf{3.2. Conversion under General Position  }$ 
>
> > ### $\textbf{3.2.0. Into}$ 
> >
> > > :one:要干啥：要将$kd\text{-}$树转化为$\text{ORP-KW}$索引
> > >
> > > :two:一些记号
> > >
> > > 1. 对象$e\in{}D\subseteq{}\mathbb{R}^2$，对象文档$e.$`Doc`(此处文档可视作==整数关键字集==)
> > > 2. 关键词总数$W:=\left|\displaystyle\bigcup_{e \in D} e . \verb|DOC|\right|$，由此所有关键词集$=[1,W]$ 
> > > 3. $k$为$\text{ORP-KW}$查询关键字数量
> > >
> > > :three:首先假设$D$处于一般位置，即$D$中点所有$xy$坐标相异 
> >
> > ### $\textbf{3.2.1. Verbose Set}$ 
> >
> > > :one:构建$D$的详细集：记$e\in{}D$被称之为$D$中的对象，记$p\in{}P$并称之为$P$中的点
> > >
> > > |    原集合$D$    |          详细集$P$           |
> > > | :-------------: | :--------------------------: |
> > > | 单个$e_1\in{}D$ | $|e_1.$`Doc`$|$个$e_1\in{}P$ |
> > > | 单个$e_2\in{}D$ | $|e_2.$`Doc`$|$个$e_2\in{}P$ |
> > > |    ........     |           ........           |
> > >
> > > :two:==在$D$的详细集(而非$D$)上构建$kd\text{-}$树$\mathcal{T}$== 
> >
> > ### $\textbf{3.2.2. Active and Pivot Sets}$ 
> >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240808191618577.png" alt="image-20240808191618577" style="zoom:43%;" /> $\Large\xLeftrightarrow{\text{}}$<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240808192010678.png" alt="image-20240808192010678" style="zoom:33%;" />  
> > >
> > > :one:活动集
> > >
> > > 1. 普通定义：$D_u^{act}\in{}D$为$u$的活动集，即以$u$为根的子树所对应$\mathbb{R}^2$中的点
> > > 2. 递归定义：$D_{root}^{act}:=D$，如果发生分割则有$\begin{cases}D_u^{act}\xLeftrightarrow{}\Delta_{u}\\\\D_{v_1}^{act}/D_{v_2}^{act}\xLeftrightarrow{}\Delta_{v_1}/\Delta_{v_2}\end{cases}$ 
> > >
> > > :two:枢纽集：
> > >
> > > 1. 定义：是活动集的一个子集，即发生分割时$\Delta_{v_1}$或$\Delta_{v_2}$边界上对象的集合
> > >
> > > 2. 性质：$D_u^{pvt} \subseteq D_u^{act} \subseteq D$，$|D_u^{pvt}|=O(1)$  
> >
> > ### $\textbf{3.2.3. Large and Small Keywords at a Node  }$ 
> >
> > > :one:一些记号
> > >
> > > 1. $D_u^{act}(\mathrm{w}) := \left\{ e \in D_u^{act} \mid \mathrm{w} \in e . \verb|DOC| \right\}$，即$u\in{}\mathcal{T}$结点活动集中包含有所有$\mathrm{w}$关键词的对象
> > > 2. $N_u := \displaystyle\sum_{e \in D_u^{act}} |e . \verb|DOC||$，即$u\in{}\mathcal{T}$结点活动集中，每个结点关键词数量的总和
> > >    - 其中$ N_u \leq \left|P_u\right| = O\left(\cfrac{N}{2^{\text{level }(u)}}\right) $，注意$P_u$中是存储了副本的
> > >
> > > :two:大小关键字
> > >
> > > 1. 定义：如果$ \left|D_u^{act}(\mathrm{w})\right| \geq N_u^{1-\cfrac{1}{k}} $，则称$\mathrm{w}$在$u$处为大关键字，反之为小关键字
> > > 2. 性质：$u$处最多只能有$ N_u^{\frac{1}{k}} $个大关键字
> >
> > ### $\textbf{3.2.4. Structure  }$ 
> >
> > > :one:$u$的附属二级结构$T_u$
> > >
> > > |                          $T_u$输入                           |                          $T_u$输出                           |     适用      |
> > > | :----------------------------------------------------------: | :----------------------------------------------------------: | :-----------: |
> > > |                           结点$u$                            |                      枢纽集$D_u^{pvt}$                       | 中间$+$叶结点 |
> > > |                 结点$u$，关键字$\mathrm{w}$                  |               $\mathrm{w}$在$u$是否为大关键字                |   中间结点    |
> > > | 结点$u$，$u$处$k$个大关键字$\mathrm{w}_1, \ldots, \mathrm{w}_k$，$u$子节点$v$ | $\displaystyle{}\bigcap_{i=1}^k D_v^{act}\left(\mathrm{w}_i\right)$是否为空 |   中间结点    |
> > >
> > > - 执行时间至少要$O(N_u^{\frac{1}{k}})\text{ word}+O(N_u)\text{ bit}$ 
> > >
> > > :two:$D_u^{act}(\mathrm{w})$的物化($\text{materialized}$)
> > >
> > > 1. 含义：选取$u\in{}\mathcal{T}$以及$\mathrm{w}\in{[1,W]}$中一部分的$D_u^{act}(\mathrm{w})$，从概念模型存储到物理实体
> > > 2. $D_u^{act}(\mathrm{w})$物化要满足的条件(选取标准)
> > >    - $\mathrm{w}$是$u$处的小关键字
> > >    - $\mathrm{w}$在$u$的所有祖先节点处为大关键字
>
> ## $\textbf{3.3. Bounding the Crossing Sensitivity  }$ 
>
> > ### $\textbf{3.3.0. Intro}$
> >
> > > :one:要干啥：用转换框架回答$\text{ORP-KW}$查询
> > >
> > > :two:咋办：引入交叉敏感性概念，用于衡量集合索引(此处的$kd\text{-}$树)对转换框架的友好程度
> >
> > ### $\textbf{3.3.1. Algorithm  }$ 
> >
> > > :one:算法输入给定查询：其中几何查询为矩形$q$，关键字查询为$\mathrm{w}_1, \ldots, \mathrm{w}_k$ 
> > >
> > > :two:算法的一些模块化操作
> > >
> > > 1. 访问操作：访问结点$u$的操作
> > >
> > >    - 读取$\forall{}e\in{}D_u^{pvt}$ 
> > >    - 检查$e$是否被矩形$q$覆盖$+e.$`Doc`是否包含所有关键词$\mathrm{w}_1, \ldots, \mathrm{w}_k$ ，检查都通过就报告$e$ 
> > >
> > > 2. 下降判断操作：判断是否访问$u$的子节点$v$的操作，要求以下两个操作返回==是==
> > >
> > >    - 利用$T_u$判断：令$\mathbb{W}=\{\mathrm{w}_1, \ldots, \mathrm{w}_k\}$
> > >
> > >      $u+关键字集\mathbb{W}\xrightarrow{T_u}\begin{cases}\mathbb{W}在u都为大关键字+子节点v\xrightarrow{T_u}\begin{cases}\displaystyle{}\bigcap_{i=1}^k D_v^{act}\left(\mathrm{w}_i\right)空\to{否}\\\\\displaystyle{}\bigcap_{i=1}^k D_v^{act}\left(\mathrm{w}_i\right)不空\to{是}\end{cases}\\\\\mathbb{W}在u存在小关键字\to{}否\end{cases}$ 
> > >
> > >    - 矩形$q$与子节点对应矩形$\Delta_v$有交叉$\to{}$是
> > >
> > > 3. 停止下降后的报告操作：假设$\mathrm{w}_1, \ldots, \mathrm{w}_k$在$u$处有小关键字$\mathrm{w}_i$因而停止下降
> > >
> > >    - 物化$D_u^{act}\left(\mathrm{w}_1\right)$，即$u$的活动集中包括了$\mathrm{w}_i$关键词的对象
> > >    - 读取$\forall{}e\in{}D_u^{act}\left(\mathrm{w}_i\right)$
> > >    - 检查$e$是否被矩形$q$覆盖$+e.$`Doc`包含关键词$\mathrm{w}_1, \ldots, \mathrm{w}_{i-1},\mathrm{w}_{i+1}\ldots\mathrm{w}_k$ ，都成立就报告$e$ 
> > >
> > > :three:算法流程：执行结束后输出${}=q \cap D\left(\mathrm{w}_1, \ldots, \mathrm{w}_k\right)$  
> > >
> > > <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240809200459993.png" alt="image-20240809200459993" style="zoom:40%;" /> 
> >
> > ### $\textbf{3.3.2. Analysis}$ 
> >
> > > :one:查询生成树：
> > >
> > > 1. 含义：令查询$\mathcal{T}_{\text {}}$过程中遍历过的结点形成$\mathcal{T}_{\text {qry}}$树
> > > 2. 结点分类：对于$u\in{}\mathcal{T}_{\text {qry}}$及其矩形$\Delta_{}u$，以及给定$q$ 
> > >    - 覆盖结点：$\Delta_u$被 $q$ 完全覆盖
> > >    - 交叉结点：其它情况，此外记$\mathcal{T}_{\text {qry}}\xrightarrow{删除所有覆盖结点}\mathcal{T}_{\text {cross}}$ 
> > >
> > > :two:复杂度分析：
> > >
> > > 1. 单个结点耗时${}\to{}\begin{cases}\mathcal{T}_{\text {qry}}中间结点\text{: }耗时O(1)\\\\\mathcal{T}_{\text {qry}}叶子结点\text{: }耗时O\left(N_z^{1-\frac{1}{k}}\right)\end{cases}$ 
> > > 2. 覆盖结点总耗时${}\to{}O\left(N^{1-\cfrac{1}{k}}\left(1+\mathrm{OUT}^{\cfrac{1}{k}}\right)\right)$ (==引理$9$==)
> > > 3. 交叉结点总耗时${}\to{}\displaystyle{}\sum_{\text {int } u \text { of } \mathcal{T}_{\text {cross }}} 1+\sum_{\text {leaf } z \text { of } \mathcal{T}_{\text {cross }}} N_z^{1-\frac{1}{k}}$ 
> > >    - 这就是所说的==交叉敏感性== 
> > >    - 对于大多几何索引覆盖节点总耗时都成立，真正差异化的是交叉敏感性
> >
> > ### $\textbf{3.3.3. Crossing Sensitivity of kd-Tree}$ 
> >
> > > :one:对任意二维矩形，其交叉敏感性为$O\left(N^{1-\frac{1}{k}}\right)$
> > >
> > > - 证明过程见原论文
> > >
> > > :two:结合==引理$9$==$\to{}\text{ORP-KW}$查询的时间上界为$O\left(N^{1-\cfrac{1}{k}}\left(1+\mathrm{OUT}^{\cfrac{1}{k}}\right)\right)$ 、
> >
> > ### $\textbf{3.3.4. Removing General Position  }$ 
> >
> > > :one:一般位置假设：即$D$中任意两点，没有共享的$x/y$坐标
> > >
> > > :two:消除假设的方法：将原始坐标$\xrightarrow{转化}$秩空间
> > >
> > > 1. 将$x/y$按照坐标排序，若存在并列的则按照坐标对应点的$\text{ID}$再排
> > > 2. 复杂度为$O(\log{}N)$ 

# $\textbf{4. Dimension Reduction Under KW}$  

> ## $\textbf{4.0. Intro}$ 
>
> > :one:==引理$11$==：对于$\text{ORP-KW}$索引
> >
> > - 如果可以为$d=\lambda{}\geq{}2$构建索引$\to{}\begin{cases}索引空间\text{: }O\left(N \cdot(\log \log N)^{\lambda-2}\right)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{k}}\cdot\left(1+\text{OUT}^{\cfrac{1}{k}}\right)\right)\end{cases}$ 
> >
> > - 则也可以为$d=\lambda{}+1$构建索引$\to{}\begin{cases}索引空间\text{: }O\left(N \cdot(\log \log N)^{\lambda-1}\right)\\\\查询时间\text{: }O\left(N^{1-\cfrac{1}{k}}\cdot\left(1+\text{OUT}^{\cfrac{1}{k}}\right)\right)\end{cases}$
> > -  $\text{Ps. }$所讨论的对象集$e\in{}D\subset{}\mathbb{R}^{\lambda{}+1}$，并称第一维度为$x$维
> >
> > 
> >
> > :two:子集权重
> >
> > 1. 定义：$\displaystyle{}\text {weight }\left(D^{\prime}\right):=\sum_{e \in D^{\prime}\subseteq D} \mid e . \verb|DOC| \mid$ 
> > 2. 性质：$\text{weight}\left(D^{\prime}\right) \geq\left|D^{\prime}\right|$恒成立
> >
> > :three:$D^{\prime}$的$f\text{-}$平衡分割：无论$D^{\prime}$和$f$如何，总有一元组$\left(D_1, D_2, \ldots, D_f, e_1^*, e_2^*, \ldots, e_{f-1}^*\right)$满足
> >
> > 1. $D_i\subseteq{}D$，$e_i\in{}D^{\prime}$或者$e_i=\text{null}$ 
> > 2. $D_1, D_2, \ldots, D_f,\left\{e_1^*\right\},\left\{e_2^*\right\}, \ldots,\left\{e_{f-1}^*\right\}$彼此互斥，并且并集为$D^{\prime}$ 
> > 3. $D_i$中每个对象的$x$坐标，都小于$D_{i+k}$中每个对象的$x$坐标
> > 4. $\text{weight}\left(D_{i}\right) \leq\cfrac{\text{weight}\left(D_{i}\right)}{f}$ 
> >
> > :four:要干啥：
> >
> > 1. 证明==定理$2$==，尤其是为何从三维开始每增加一个维度，空间消耗增加$O(\log \log N)$ 
> > 2. 怎么证明：先证明==引理$11$==，让其与==定理$1$==结合，即可证明==定理$2$==
>
> ## $\textbf{4.1. Structure  }$ 
>
> > :one:树$\mathcal{T}$的定义
> >
> > 1. $u\in{\mathcal{T}}$中活动集$D_u^{act}$：与先前定义一样，就是结点$u$对应的$e$的集合
> >
> > 2. $u\in{\mathcal{T}}$中枢纽集$D_u^{pvt}$：对$D_u$任意$f_u\text{-}$平衡切割$\left(D_1, \ldots, D_{f_u}, e_1^*, \ldots, e_{f_u-1}^*\right)$其中${}f_u:=2 \cdot 2^{k^{\text{level}(u)}}$
> >    - 对于$u$本身：$D_u^{pvt}:=\left\{e_1^*, \ldots, e_{f_u-1}^*\right\}$ 
> >    - 对于$u$的子节点${}v\to{}\begin{cases}D_1, \ldots, D_{f_u}皆空\to{}u为叶结点(v不存在)\\\\否则\to{}为每个非空D_i创建子节点\to{}D_v^{act}:=D_i\end{cases}$ 
> >
> > :two:$\forall{}u\in{}\mathcal{T}$的次级结构：$\text{input}\xrightarrow{T_u}\text{output}$
> >
> > 1. $\text{input}$内容
> >    - $u\in{}T$ 
> >    - $k$个关键词$\mathrm{w}_1, \ldots, \mathrm{w}_k$
> >    - 一个$ (\lambda+1)\text{-}$矩形$q$，其在第一维度$x$轴的投影为$(-\infty, \infty)$
> > 2. $\text{output}$内容：$e\in{}D_u^{act}$且满足
> >    - $e$被矩形$q$覆盖
> >    - $e.$`Doc`包含所有关键词$\mathrm{w}_1, \ldots, \mathrm{w}_k$ 
> > 3. 忽略$x$维后可视$T_u$为$d=\lambda$的$\text{ORP-KW}$索引
>
> ## $\textbf{4.2. Query  }$ 
>
> > :one:一些记号
> >
> > 1. $\sigma(u)$为覆盖$D_u^{act}$中所有点的$x$坐标的最紧密区间
> > 2. $q[i]$为$q$在$i \in[1, \lambda+1]$上的投影区间，$q[1]$是$x$维的区间
> >
> > :two:查询操作：输入$ (\lambda+1)\text{-}$矩形$q$，关键词$\mathrm{w}_1, \ldots, \mathrm{w}_k$ 
> >
> > 1. 访问满足以下条件的结点$u\in{}\mathcal{T}$，并将被访问到的结点踢出为$\mathcal{T}_{\text {qry}}$ 
> >
> >    - $\sigma(u) \cap q[1] \neq \emptyset$
> >    - $u$的所有祖先$v$的$\sigma(v)$，都没完全包含在$q[1]$中
> >
> > 2. 将$\mathcal{T}_{\text {qry}}$中的点分类
> >
> >    <img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20240810010301831.png" alt="image-20240810010301831" style="zoom: 33%;" /> 
> >
> >    - 类型$1$(图中黑点)：$\sigma{(u)}\subseteq{}q[1]$
> >    - 类型$2$(图中白点)：其它结点，每层最多只有两个白点
> >
> > 3. 报告对象
> >
> >    - 对类型$1$的点：执行$T_u$以报告对象
> >    - 对类型$2$的点：检查并报告枢纽集中合要求的对象，时间开销$O\left(\left|D_u^{pvt}\right|\right)=O\left(f_u\right)$ 
>
> ## $\textbf{4.3. Analysis}$ 
>
> > :zero:基础命题
> >
> > 1. $\mathcal{T}$有$O(\log \log N)$层
> > 2. $\forall{}u\in{}\mathcal{T}$有$\text{weight} \left(D_u^{act}\right) \cdot f_u^{\frac{1}{k-1}}=O\left(\cfrac{N}{2^{\text{level }(u)}}\right)$ 
> > 3. $\forall{}u\in{}\mathcal{T}$有$f_u=O\left(N^{1-\frac{1}{k}}\right)$ 
> >
> > :one:空间复杂度分析
> >
> > 1. $\mathcal{T}$每层结点的辅助结构总占用空间$O\left(N \cdot(\log \log N)^{\lambda-2}\right)$ 
> > 2. 由于$\mathcal{T}$有$O(\log \log N)$层故总空间为$O\left(N \cdot(\log \log N)^{\lambda-1}\right)$
> >
> > :two:时间复杂度分析
> >
> > 1. 类型$1$结点成本：$O\left(N^{1-\frac{1}{k}}\right)$ 
> > 2. 类型$2$结点成本：$O\left(N^{1-\frac{1}{k}}\right)$ 



