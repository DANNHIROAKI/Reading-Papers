[原文章](https://cs.stanford.edu/~rishig/courses/ref/l13a.pdf) 

@[toc]

# $\textbf{1. }\textbf{Cuckoo Hashing}$方案

> :one:数据结构：
>
> 1. 哈希表：创建$n$个哈希表$T_1,T_2,...,T_n$
> 2. 哈希函数：每个哈希表$T_i$都有各自的独立的哈希函数$h_i$，$h_i(x)$决定了$x$在$T_i$表中的分桶
> 3. 哈希桶：每个哈希表$T_i$有各自独立的$r$个桶即$T_i[0],T_i[1],...,T_i[r–1]$，一共有$nr$个桶
>
> :two:查找$/$删除算法：
>
> 1. 计算桶：在$n$个哈希表中找到查询$q$所在的桶$T_1[h_1(q)],T_2[h_2(q)],...,T_n[h_n(q)]$
> 2. 查找：检查所有这些桶中是否含$q$，若某一桶中含有$q$则返回查询成功
> 3. 删除：检查所有这些桶中是否含$q$，遇到某桶含有$q$则进行删除
>
> :three:插入算法：设置每个桶数量最大值$\text{MaxNum}$，最大插入次数$\text{MaxLoop}$
>
> 1. 计算桶：在$n$个哈希表中找到待插入对象$x$的候选桶$T_1[h_1(x)],T_2[h_2(x)],...,T_n[h_n(x)]$
> 2. 初步插入：
>    - 成功：优先尝试将$x$插入到没达到阈值$\text{MaxNum}$的任一桶$T_i[h_i(x)]$中
>    - 失败：如果所有桶对象数目都大于阈值$\text{MaxNum}$，则随机选取桶$T_i[h_i(x)]$强行插入$x$并驱赶其任一个原有对象$y$
> 3. 重新插入：计算$y$的候选桶$T_1[h_1(y)],T_2[h_2(y)],...,T_n[h_n(y)]$，按照同样的策略将$y$插入到桶$T_i[h_i(y)]$
> 4. 算法终止：
>    - 收敛情形：不断插入$\text{+}$驱赶一直到到不再有驱赶发生，用优先队列避免驱赶时形成回路(比如待插入键变化为$x\text{→}y\text{→}x$)
>    - 不收敛情形：当插入次数达到设定的最大值$\text{MaxLoop}$时，重建所有的哈希表然后重新执行插入$x$



