## 概述：Cuckoo Hashing

## 1 摘要

Cuckoo Hashing 是一种用于解决哈希表冲突的技术，能够生成一个字典结构，该字典支持最坏情况下的常数时间查找和删除操作，以及均摊常数时间的插入操作。该方法最早由 Pagh 在 2001 年提出 [3]，是对之前静态字典数据结构的一种扩展，并且是首个具有实际较小常数因子的此类哈希表 [4]。在此，我们首先==概述现有的哈希表冲突解决策略==，然后==详细分析 Cuckoo Hashing 方案==。接下来，我们==介绍 $(c, k)$-通用哈希函数族==，最后总结一些比较不同冲突解决策略的选定实验结果。

## 2 引言

字典是计算机科学中最基本的数据结构之一，允许用户存储键值对，并通过键在数据结构中查找对应的值。哈希表提供了字典数据结构最常见且最快的实现方式之一，能够实现均摊常数时间的查找、插入和删除操作。在其典型形式中，一个定义在键空间上的哈希函数 $ h $ 被用来将每个键映射到一组桶位置集合 $\{b_0, \cdots, b_{r-1}\}$ 中的一个位置。在插入时，键以及可能包含的一些辅助数据（称为值）会被存储到相应的桶位置；在删除时，键及其值会从相应的桶中移除；而在查找时，通过查看与哈希键值相对应的桶位置，可以检索到该键值对（如果存在）。在此，对于一个具有哈希函数 $ h $ 的哈希表 $ T $ 和一个键 $ x $，我们用 $ T[x] $ 表示桶位置 $ b_x $。

- 我们说某个操作是以均摊常数时间完成的，其含义是：尽管某次操作的具体调用可能会产生较大的运行时间开销（例如，在哈希表中，当元素数量增加时可能需要调整表的大小），但从大量操作的整体来看，这些调用的平均运行时间是常数。

---

这种利用哈希函数将键值对均匀分布到桶中的通用方案，使得基于哈希的字典在预期的渐进性能上优于其他字典方案，包括例如平衡二叉树字典。在搜索树中，通过对可能的键集确定一个固定的顺序来定位特定的键。而在哈希表中，使用键的哈希函数将可能的键映射到桶中，这样不同键被映射到同一个桶的概率较低。然而，在没有完美的哈希函数将键单射地映射到桶位置的情况下，必须解决两个不同键映射到同一个桶位置的冲突问题。

---

为了应对冲突，已经提出了多种具有不同性能特征的解决方案。Cuckoo Hashing（ cuckoo 哈希）是一种简单的解决冲突的方案，它支持最坏情况下的常数时间查找和删除操作，以及均摊常数时间的插入操作。简要来说，Cuckoo Hashing 维护两个哈希表 $T_1$ 和 $T_2$，分别对应两个独立的哈希函数 $h_1$ 和 $h_2$，每个键会被存储在这两个位置之一，且每个哈希表中各有一个可能的位置。查找键 $x$ 时，只需在桶位置 $T_1[h_1(x)]$ 或桶位置 $T_2[h_2(x)]$ 中寻找匹配项即可。删除操作可以通过从任意可能的桶位置移除键来完成，但插入操作更为复杂，将在第 5 节中详细分析。该方案的具体描述见第 4 节。

- Cuckoo Hashing 的命名来源于布谷鸟的寄生繁殖行为：布谷鸟以其在其他鸟类的巢中产卵而闻名，当这些卵孵化后，布谷鸟幼鸟通常会将宿主鸟的卵推出巢外。在 Cuckoo Hashing 的上下文中，当键被插入到已有键的哈希表桶中时，原有的键会被“驱逐”并被迫移动到另一个哈希表中的备用位置。因此，在某种意义上，这模仿了布谷鸟的行为。

---

为了更全面地了解各种哈希方案的范围，并为与 Cuckoo Hashing 的理论和实验比较提供基准，我们在下一节中首先介绍几种先前的哈希方案的细节：链式哈希（chained hashing）、线性探测（linear probing）和双向链表（two-way chaining）。

## 3 之前的哈希方案

在我们对哈希表的描述中，使用 $ n $ 表示插入到哈希表中的项目数量，$ r $ 表示哈希表中的桶数量，并定义负载因子 $ n / r $ 作为预期桶数的度量。

---

**链式哈希（Chained hashing）。** 在链式哈希方案中，使用链表存储所有哈希到特定桶位置的键。因此，冲突通过延长发生冲突的桶中的链表结构来解决。插入操作可以通过将新键附加或前置到相关桶的链表中，在常数时间内完成，但查找和删除操作可能需要遍历整个链表。当这些链表变长时，即当哈希表的负载因子较高时，哈希表的性能会下降。通过选择适当的时机调整哈希表大小，可以确保查找和删除操作在均摊常数时间内完成。然而，与 Cuckoo Hashing 不同的是，链式哈希无法提供最坏情况下的常数时间查找保证。

---

**线性探测（Linear probing）。** 在线性探测方案中，键被哈希以生成一个桶索引，并尽可能存储在该桶位置。在插入时，如果目标桶位置已被其他键占用，则按顺序扫描桶位置，直到找到一个空桶来存储该键。在查找某个键时，首先对该键进行哈希以确定桶位置，然后从该桶开始依次扫描连续的桶，直到找到目标键或遇到空桶为止。显然，这种插入和查找方案在最坏情况下无法保证合理的常数时间运行时间界限，因为大块连续非空桶可能会导致在找到正确桶之前访问许多桶。删除键可以通过将包含该键的桶标记为特殊的 DELETED 值来实现，该标记会保留直到哈希表被周期性重建或调整大小。一种更复杂的删除方案是检查包含待删除键的连续非空桶簇，清空包含该键的桶，并在必要时重新排列键以填补因删除键而留下的“空洞”，从而确保查找操作能够成功。

---

线性探测是一种开放地址法的冲突解决策略，其中哈希冲突通过在桶数组的一组备用位置中进行探测来解决。类似的开放地址法还包括二次探测（quadratic probing），在这种方法中探测间隔呈二次增长；以及双重哈希（double hashing），在这种方法中，给定键的探测距离是线性的，但由该键的另一个哈希函数值决定。

---

**双向链表（Two-way chaining）。** 在双向链表方案中，使用两个哈希表和两个独立的哈希函数，使得每个可能的键在每个哈希表中都被哈希到一个桶位置。每个桶包含一个哈希到该桶的项目列表，类似于链式哈希的情况。当插入一个键时，它会被插入到对应桶位置中键数量较少的那个哈希表中。在查找和删除操作中，会遍历两个表中的列表以定位给定的键。由于选择键数量最少的桶这一操作能够以高概率“均衡”键在桶中的分布，因此该方案的性能通常优于链式哈希。Azar 和 Broder [1] 的分析表明，在假设随机哈希函数的情况下，该方案可以实现 $O(\log \log n)$ 的最大列表长度和查找时间（以高概率）。该方案与 Cuckoo Hashing 共享了一种设计思想，即为每个键指定两个哈希表中的可能存储位置。

## 4 Cuckoo Hashing 的描述

Cuckoo Hashing 是一种哈希表方案，使用两个哈希表 $T_1$ 和 $T_2$，每个哈希表有 $r$ 个桶，并分别配备独立的哈希函数 $h_1$ 和 $h_2$，它们将键空间 $U$ 映射到桶位置集合 $\{0, \cdots, r-1\}$。一个键 $x$ 可以存储在位置 $T_1[h_1(x)]$ 或 $T_2[h_2(x)]$ 中的一个且仅一个位置。在 Cuckoo Hashing 中，查找操作会检查两个位置 $T_1[h_1(x)]$ 和 $T_2[h_2(x)]$，如果键 $x$ 存储在这两个位置中的任何一个，则查找成功。因此，以下算法正式描述了 Cuckoo Hashing 的查找行为。

```
function lookup(x)
    return T1[h1(x)]=x ∨ T2[h2(x)]=x
end
```

---

显然，该算法在最坏情况下能够在常数时间内完成。删除操作也非常简单，因为我们只需从包含该键的桶中移除它即可。对于 Cuckoo Hashing 而言，也是我们分析的重点问题是：给定哈希函数 $h_1$ 和 $h_2$ 以及一组要存储在哈希表中的键，这些键能够被放置到桶中的概率是多少，使得对于每个键 $x$，要么 $T_1[h_1(x)] = x$，要么 $T_2[h_2(x)] = x$？此外，我们是否可以展示一种高效的插入方案以达到这样的配置？Pagh 曾经证明，对于随机选择的 $h_1$ 和 $h_2$，如果 $r \geq (1+\epsilon)n$ [3]，即每个哈希表的大小至少是键总数的 $1+\epsilon$ 倍（对于某个 $\epsilon$），那么键无法被放置到这种配置中的概率为 $O(1/n)$。更具体地，我们展示了一种简单的插入过程，该过程允许均摊常数时间的插入操作。

---

在我们的插入过程中，我们将一个键放置到两个表中为其指定的位置之一，并驱逐已经存在的任何键。随后，我们尝试将被驱逐的键插入到另一个哈希表中其备用桶位置，可能会再次驱逐另一个键，如此继续，直到某个键被插入到空桶中，或者在经过一定次数的迭代后，我们决定重新哈希整个表并重试。该过程的一个简单实例如图 4 所示。

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250225222022020.png" alt="image-20250225222022020" width=700 /> 

Figure 1: An instance of the insertion procedure for $x$.

---

可以想象，一般的插入过程更为复杂，并且某些键可能会被多次重新访问。在某些情况下，所有现有的键可能无法成功放置到 Cuckoo Hashing 结构中，因此需要对表进行重新哈希。因此，我们将设定一个最大循环次数阈值（MaxLoop），如果超过该阈值仍未完成插入，则使用重新哈希的表重试。

---

正式地，这一过程由以下算法描述，在此我们任意选择优先尝试将键插入到 $T_1$ 中。$^3$ 在这里，我们用 $a \leftrightarrow b$ 表示交换 $a$ 和 $b$ 的值，并用 $\perp$ 表示空值。

- 直观上，选择优先将 $x$ 插入到 $T_1$ 而不是采用其他方案（例如，当 $T_1[h_1(x)]$ 被某个其他键 $y$ 占用时检查 $T_2[h_2(x)]$）在插入循环中的迭代次数期望成本上是微不足道的。因为对于随机哈希函数，$T_2[h_2(x)]$ 被占用的概率等于被驱逐的键 $y$ 对应位置 $T_2[h_2(y)]$ 被占用的概率，并且在这两种情况下，期望的单元访问次数是相等的。实验上，Pagh 和 Rodler [4] 发现，在负载因子为 $1/3$ 时，即使同时检查 $T_1[h_1(x)]$ 和 $T_2[h_2(x)]$，也只有 $10\%$ 的新键会被放置到 $T_2$ 中，因此额外进行一次检查并没有显著的优势。

```
procedure insert(x)
    if lookup(x) then return
    loop MaxLoop times
        x <-> T1[h1(x)]
        if x=⊥ then return
        x <-> T2[h2(x)]
        if x=⊥ then return
    end loop
    rehash() ; insert(x);
end
```

---

我们在下一节中分析这一过程，并证明使用 $ \text{MaxLoop} = \lceil 3 \log_{1+\epsilon} r \rceil $ 的值将导致均摊常数时间的插入操作。

与许多其他哈希方案一样，随着负载因子 $ r / n $ 的增加，性能会下降。因此，我们坚持让我们的哈希表大小至少为 $ r \geq (1+\epsilon)n $（对于某个常数 $ \epsilon $），这个不变量将在下一节的运行时分析中派上用场。我们通过在每次插入后，当 $ r < (1+\epsilon)n $ 时，将表的大小加倍并重新哈希来实现这一点，并且在下一节中我们将证明每次插入时，这是一项均摊常数时间的操作。

## 5 Cuckoo Hashing 的运行时分析

在本节中，我们证明了给定键在插入循环中的期望迭代次数是常数。我们进一步证明，重新哈希一个包含 $ n $ 个元素的 Cuckoo Hashing 结构的期望时间为 $ O(n) $，并利用这一结果得出结论：Cuckoo Hashing 的插入操作（包括任何重新哈希）是一个均摊常数时间的操作。

### 5.1 哈希函数族假设

在我们的分析中，由于我们需要考虑一组键哈希到特定桶排列的概率，因此需要对选择 $h_1$ 和 $h_2$ 的哈希函数族提供通用性保证。Pagh 和 Rodler 提出了 $(c, k)$-通用哈希函数的概念以提供这种保证。为了简化分析，我们假设以概率 $1 - O(1/n^2)$，我们的哈希函数 $h_1$ 和 $h_2$ 是从所有映射 $O \to \{0, \cdots, r-1\}$ 中随机抽取的；而以概率 $O(1/n^2)$，我们不对 $h$ 做任何假设（在此情况下，$h$ 可能是一个病态映射）。在第 6 节中，我们将介绍 $(c, k)$-通用性的概念，并证明在这种较弱的通用性假设下，本节中开发的运行时分析仍然成立。

### 5.2 扩容分析

在这里，我们证明每次插入操作的哈希表扩容均摊成本为 $O(1)$。在我们的分析中，我们确保每个哈希表的大小至少为 $r \geq (1+\epsilon)n$（对于某个常数 $\epsilon$）。我们通过在必要时将哈希表的大小加倍来实现这一点，即每当 $r < (1+\epsilon)n$ 时进行调整。我们将在第 5.2 节中证明重新哈希一个大小为 $n$ 的表需要 $O(n)$ 的期望时间。对于插入到哈希表中的 $n$ 个项目，我们期望进行 $O(\log n)$ 次扩容和重新哈希操作，其规模分别为 $n, n/2, \cdots, n/2^{O(\log n)}$，总运行时间为至多 $O(n + n/2 + \cdots + n/2^{O(\log n)}) < O(n + n/2 + n/4 + \cdots) = O(n)$。将此成本均摊到 $n$ 个项目上，每次插入操作所需的必要扩容的均摊成本为 $O(1)$。

### 5.3 插入迭代分析

在这里，我们证明某个键在插入循环中花费的期望迭代次数为 $O(1)$。我们首先分析插入操作进展的三种情况。接下来，我们证明一个关于遇到的一系列键的引理。最后，我们证明插入循环中期望迭代次数的一个上界。

### 5.3.1 插入概述

考虑将键 $x$ 插入到 Cuckoo Hashing 结构中，以及随后的一系列驱逐和递归插入操作。如果选择存储 $x$ 的桶已经被另一个键 $y$ 占用，则键 $y$ 将被驱逐到另一个哈希表中的备用位置；如果该桶又被键 $z$ 占用，则键 $z$ 被驱逐到其备用位置，依此类推。我们将这一系列键记为 $x_1 = x, x_2 = y, x_3 = z, \cdots$，称为无巢键序列。此过程可能以以下三种方式之一进行：

**情况 1**：所有无巢键都是唯一的，这意味着插入过程终止。

**情况 2a**：无巢键重复，即无巢键 $x_i$ 第二次在位置 $x_j$ 被驱逐（在此及下一情况中，对于某些 $(i, j)$，有 $x_i = x_j$，并且我们假设 $(i, j)$ 是满足该条件的字典序最小的有序对），但当某个无巢键移动到空桶时，插入过程终止。

**情况 2b**：无巢键重复，但插入过程未终止。

---

**情况 1 的分析**：所有无巢键都是唯一的。这是最简单的情况：在这里，一系列驱逐操作最终导致最后一个无巢键 $x_p$ 被驱逐到一个空桶中，从而结束插入过程。图 5.3.1 给出了这种情况的一个示例：在这些图中，我们将键表示为带标签的圆圈，并用箭头指向可以存储它的两个桶（用正方形表示）。当一个键存储在一个桶中时，其箭头指向另一个哈希表中可以存储它的备用桶（这里为了简化，省略了桶与两个哈希表之间的关联）。当由于我们的插入过程，某个桶持有的键与过程开始时不同，我们用粗线标记该桶的轮廓。
<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250225222554710.png" alt="image-20250225222554710" width=600 /> 

Figure 2: Case 1: the insertion of $x_{1}$ evicts $x_{2}$, which in turn evicts $x_{3}$, which finally moves to an empty bucket.

---

**情况 2 的分析：** 无巢键 $x_1 = x, x_2, \cdots$ 出现重复。假设无巢键 $x_i$ 第二次在位置 $x_j$ 被驱逐，其中 $x_i = x_j$ 且 $i < j$，我们选择 $(i, j)$ 为满足该条件的字典序最小的有序对。在这种情况下，当 $x_i = x_j$ 第二次被驱逐后，插入过程会重新追溯其驱逐序列，使得两次被驱逐的键（从 $x_i = x_j$ 开始，接着是 $x_{i-1} = x_{j+1}, \cdots$，直到 $x_1 = x_{j+i-1}$）返回到它们的原始位置（参见图 5.3.1 中的步骤 9-12）。一旦 $x_1 = x_{j+i-1}$ 被重新驱逐为无巢键，插入过程将继续处理无巢键 $x_{j+i}, \cdots, x_l (l \geq j+i-1)$，其中要么 $x_l$ 被移动到一个空桶（情况 2a），要么 $x_l$ 驱逐了之前的某个键 $x_m$（情况 2b）。在情况 2a 中，插入过程终止；而在情况 2b 中，形成了一个包含 $l-i$ 个键的“闭合环”（即 $i$ 个键，例如 $x_i = x_j, x_{i-1} = x_{j+1}, \cdots, x_1 = x_{j+i-1}$ 被复制），这些键的哈希值分布在 $l-i-1$ 个桶中（此时插入过程中，桶中的不同无巢键恰好为 $x_2, \cdots, x_{j-1}$ 和 $x_1 = x_{i+j-1}, \cdots, x_{l-1}$，对应于 $(j-2) + (l-i-j+1) = l-i-1$ 个桶），这意味着需要重新哈希。我们在图 5.3.1 中详细展示了情况 2a 的一个执行示例（情况 2b 类似）。

### 5.3.2 插入循环引理

在分析插入循环中期望迭代次数时，我们将使用以下引理。

**引理 5.1**：假设在某一步 $p$，插入过程为 $x$ 生成了一个无巢键序列 $x_1 = x, x_2, \cdots, x_p$，且尚未形成闭合环。那么，在 $x_1, \cdots, x_p$ 中存在一个长度为 $l \geq p/3$ 的连续子序列 $x_q, x_{q+1}, \cdots, x_{q+l-1}$，其中所有无巢键均不相同，并且 $x_q = x_1 = x$。

**证明**：假设所有无巢键 $x_1, \cdots, x_p$ 都是唯一的：那么 $x_1, \cdots, x_p$ 就是这样一个序列，因此引理显然成立。现在，如果 $p < i+j$，则前 $j-1$ 个键 $x_1, \cdots, x_{j-1}$ 是唯一的，由于 $j > i$，所以 $j-1 \geq (i+j-1)/2 \geq p/2$，因此 $x_1, \cdots, x_{j-1}$ 是所需的序列。如果 $p \geq i+j$，考虑两个由不同键组成的序列 $x_1, \cdots, x_{j-1}$ 和 $x_{i+j-1}, \cdots, x_p$：我们断言其中一个序列的长度至少为 $p/3$。这两个序列分别包含 $j-1$ 和 $p-i-j+2$ 个键。注意 $p = (j-1) + (i-1) + (p-i-j+2)$，并且我们知道 $j-1 > i-1$。如果 $j-1 > p-i-j+2$，那么我们有 $3(j-1) > p$；否则，$3(p-i-j+2) \geq p$。无论哪种情况，都存在一个具有上述性质的序列。

### 5.3.3 Insertion loop analysis

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250225222816960.png" alt="image-20250225222816960" width=600 /> 

图 3：情况 2a 中描述的插入实例。

这里，考虑 $x$ 的插入过程运行以生成一个长度为 $k \leq 2 \cdot \text{MaxLoop}$ 的无巢键序列 $x_1 = x, x_2, \cdots, x_k$ 的概率（其中我们稍后会选择一个关于 $n$ 的次线性值作为 MaxLoop；此外，请注意我们的插入算法每轮迭代最多处理 2 个无巢键）。这可能发生在以下三种非互斥的情况下：

1. 哈希函数 $h_1$ 和 $h_2$ 并未随机选择。根据第 5.1 节中的假设，这种情况发生的概率至多为 $O(1/n^2)$。
2. 插入过程尚未进入闭合环路，如同第 5.3.1 节中的情况 2。我们将这一概率限制为 $2(1+\epsilon)^{-\frac{k-1}{3}+1}$，其中 $\epsilon$ 是我们在表大小不变式 $r \geq (1+\epsilon)n$ 中使用的值。
3. 插入过程已进入闭合环路。我们将这一概率限制为 $O(1/n^2)$。

然后，我们可以计算迭代循环中生成的无巢键的期望数量为
$$
\small1+\sum_{k=2}^{2 \text { MaxLoop }}\left[2(1+\epsilon)^{-\frac{k}{3}+1}+O\left(1 / n^{2}\right)\right] \leq 1+O\left(\text { MaxLoop } / n^{2}\right)+2 \sum_{k=0}^{\infty}(1+\epsilon)^{-k / 3}=O(1)+\frac{O(1)}{1-(1+\epsilon)^{-1 / 3}}=O(1)
$$

---

**情况 2 的分析。** 当插入过程尚未进入闭合环路时，引理 5.1 表明对于 $v = \lceil k / 3 \rceil$，在我们的插入过程中存在一个连续且不同的无巢键序列 $b_1 = x, b_2, \cdots, b_v$。根据定义，在我们的插入过程中，连续的无巢键具有相等的哈希函数值，并且交替使用两个哈希函数中的每一个。因此，对于 $(\beta_1, \beta_2) = (1, 2)$ 或 $(\beta_1, \beta_2) = (2, 1)$，我们有以下关系：
$$
\begin{equation*}
h_{\beta_1}(b_1) = h_{\beta_1}(b_2), \quad h_{\beta_2}(b_2) = h_{\beta_2}(b_3), \quad h_{\beta_1}(b_3) = h_{\beta_1}(b_4), \cdots \tag{5.2}
\end{equation*}
$$

我们希望对每种 $(\beta_1, \beta_2)$ 的选择来限制这种情况发生的概率。给定 $b_1 = x$，选择 $v$ 个不同键的所有可能序列少于 $n^{v-1}$ 种。此外，由于我们假设 $h_1$ 和 $h_2$ 是从键空间到 $\{0, 1, \cdots, r-1\}$ 的随机函数，等式 (5.2) 成立的概率为 $r^{-(v-1)}$。结合以上两点，这意味着存在上述 $b_1, \cdots, b_v$ 的概率至多为：
$$
\begin{equation*}
2 n^{v-1} r^{-(v-1)} = 2(r/n)^{-(v-1)} < 2(1+\epsilon)^{-\lceil k/3 \rceil + 1} \leq 2(1+\epsilon)^{-k/3 + 1} \tag{5.3}
\end{equation*}
$$
这里我们利用了不变式 $r/n < 1+\epsilon$。由于这种情况的概率被上述 $b_1, \cdots, b_v$ 存在的概率所限制，因此该情况的概率由 (5.3) 给出。

---

**情况 3 的分析。** 在这里，我们希望限制我们的无巢键序列 $x_1, \cdots, x_k$ 进入闭合环路的概率。设 $v \leq k$ 为不同无巢键的数量。我们可以以少于 $n^{v-1}$ 种方式选择除了 $x_1 = x$ 之外的键，并在这些键中以 $r^{v-1}$ 种方式将它们分配到桶中。在闭合环路中（如第 5.3.1 节所述），我们定义 $x_i$ 和 $x_j$ 是使得 $(i, j)$ 为字典序最小的有序对，满足 $x_i = x_j$ 且 $i \neq j$，并定义 $x_l$ 是第一个满足 $x_l = x_o$（其中 $1 \leq o \leq i+j-1$）的无巢键 $l \geq i+j$。在这里，作为粗略估计，$i, j, l$ 的可能值最多为 $v^3$。由于我们假设哈希函数 $h_1$ 和 $h_2$ 是随机的，每个上述配置的概率为 $r^{-2v}$，因为每个无巢键 $y$ 必须在每个配置中设定 $h_1(y)$ 和 $h_2(y)$ 的值，而每个值出现的概率为 $1/r$。将这些结合起来并对所有可能的 $v$ 求和，我们得到这种情况的概率至多为：
$$
\begin{equation*}
\sum_{v=3}^{l} n^{v-1} r^{v-1} v^3 r^{-2v} \leq \frac{1}{nr} \sum_{v=3}^{\infty} v^3 (n/r)^v < \frac{1}{nr} \sum_{v=3}^{\infty} v^3 (1+\epsilon)^{-v} = \frac{1}{nr} O(1) = O(1/n^2) \tag{5.4}
\end{equation*}
$$
这里我们利用了不变式 $r/n < 1+\epsilon$，以及我们维持 $r = O(n)$ 的事实。

这完成了我们对插入迭代次数的分析。方程 (5.1) 因此表明，对于给定的键，插入循环中的期望迭代次数为 $O(1)$。

### 5.4 重新哈希分析

在这里，我们证明对于给定的插入操作，在适当选择 MaxLoop 的值时，执行重新哈希（即在插入算法中达到 MaxLoop 次迭代）的概率为 $O(1/n^2)$。接下来，我们证明重新哈希在 $O(n)$ 操作后成功完成。最后，我们得出结论：每次插入操作的重新哈希成本为 $O(1/n)$，这是一个常数范围内的值。

---

在上一节中，我们已经证明了对于数量为 $k$ 的无巢键序列 $x_1, x_2, \cdots, x_k$，哈希函数未随机选择的概率以及插入过程进入闭合环路的概率均被限制在 $O(1/n^2)$ 内。此外，插入过程尚未进入闭合环路的概率为 $2(1+\epsilon)^{-\frac{k}{3}+1}$。如果我们令 $k = 2 \cdot \text{MaxLoop}$ 为可能无巢键的总数，其中 $\text{MaxLoop} = \lceil 3 \log_{1+\epsilon} r \rceil$，那么我们可以得到在不进入闭合环路的情况下进行 $k$ 次迭代的概率为：

$$
2(1+\epsilon)^{-\frac{k}{3}+1} = O\left(2(1+\epsilon)^{-2 \log_{1+\epsilon} r}\right) = O(1/n^2)
$$

由于我们在 $k = 2 \cdot \text{MaxLoop}$ 次无巢键之后进行重新哈希（注意每次插入迭代会产生两个无巢键），因此任何给定插入操作导致重新哈希的概率为 $O(1/n^2)$。

---

现在，注意在重新哈希操作期间，会执行 $n$ 次插入操作，每次插入操作需要 $O(1)$ 时间，并且失败的概率为 $O(1/n^2)$，因此所有插入操作成功的概率为 $1 - O(1/n)$。对于足够大的 $n$，该概率变为 $1 - \delta$（其中 $1/2 > \delta > 0$）。因此，考虑到递归重新哈希操作，我们可以在 $O(n)$ 操作后成功完成重新哈希。

因此，我们得出结论：每次插入操作的重新哈希成本为 $O(1/n)$，这是一个常数范围内的值。因此，插入一个键 $x$ 的均摊运行时间为 $O(1)$。

## 6 $(c, k)$-通用哈希函数族

在第 5.1 节中，我们对生成哈希函数 $h_1$ 和 $h_2$ 的函数族做了很强的假设。在这里，我们引入了一个稍弱的假设，即 Pagh 和 Rodler [4] 使用的 $(c, k)$-通用性概念。

### 6.1 定义

我们定义一个将全集 $U$ 映射到集合 $R$ 的哈希函数族 $\{h_i\}_{i \in I}$ 是 $(c, k)$-通用的，如果对于任意 $k$ 个不同的元素 $x_1, \cdots, x_k \in U$ 和任意值 $y_1, \cdots, y_k \in R$，满足以下条件：

$$
\begin{equation*}
\operatorname{Pr}_{i \in I}\left[h_{i}(x_{1})=y_{1}, \cdots, h_{i}(x_{k})=y_{k}\right] \leq c /|R|^{k} . \tag{6.1}
\end{equation*}
$$

直观上，这意味着在这个哈希函数族中，任意 $k$ 个元素被映射到 $R$ 中特定值的概率最多是 $h_i$ 为从 $U$ 到 $R$ 的随机函数时概率的 $c$ 倍。在 $(c, k) = (1, 2)$ 的情况下，我们恢复了常见的“标准通用哈希函数族”的概念。需要注意的是，这样的 $(1, 2)$-通用哈希函数族在我们的分析中并不足够，因为在本分析中，我们需要同时对多于 2 个哈希值提供保证。此外，任何 $(c, k)$-通用哈希函数族也是 $(c, l)$-通用的（对于任意 $2 \leq l \leq k$），因为沿 (6.1) 的边际求和可以得到所需的结果。

### 6.2 在 Cuckoo Hashing 分析中的应用

Pagh 和 Rodler [4] 使用 Siegel [5] 的构造方法构建了一族哈希函数，当限制在任意 $r^2$ 个键的集合上时，该函数族是 $(1, n^\delta)$-通用的（对于某些 $\delta > 0$，特别地，$n^\delta > \text{MaxLoop}$）。在第 5.3.3 节插入循环分析的案例 1 中，失败条件变为 $h_1$ 和 $h_2$ 不是 $(1, \text{MaxLoop})$-通用的概率为 $O(1/n^2)$。在案例 2 中，$(1, \text{MaxLoop})$-通用性条件保证了 (5.2) 仍然以概率 $r^{-(v-1)}$ 成立；类似地，在案例 3 中，该条件保证了每个描述的配置发生的概率为 $r^{-2v}$。

### 6.3 实践中的哈希函数

在上述分析中，我们改进了方法，使用了一种已被证明可构造的哈希函数族。然而，这种哈希函数族在实践中并未被采用，因为它不支持快速计算。因此，在实际应用中，Cuckoo Hashing 使用的哈希函数族具有比我们分析中使用的更弱的性质。

---

在 Pagh 和 Rodler [4] 的实验研究中发现，与其他哈希方案不同，Cuckoo Hashing 对生成 $h_1$ 和 $h_2$ 所使用的哈希函数族非常敏感。Pagh 和 Rodler 考虑了来自文献 [2] 中的一类由奇数整数 $a$ 参数化的哈希函数族，这些函数将输入映射到 $\{0,1\}^q$，定义为 $h_a(x) = (a x \bmod 2^w) \operatorname{div} 2^{w-q}$。当 $a$ 使用 C 语言的 `rand` 函数选择时，性能会下降。Pagh 和 Rodler 采用的解决方法是将 $h_1$ 和 $h_2$ 定义为从上述函数族中独立选择的三个函数的异或结果。理论上为什么这种方法有效尚不清楚，但由此产生的哈希函数在 Cuckoo Hashing 中表现良好。

## 7 与先前哈希函数族的比较

Pagh 和 Rodler [4] 进行了实验，测量了 Cuckoo Hashing 在链式哈希、线性探测和双向链表等优化实现中的运行时间。从时钟周期的角度来看，Cuckoo Hashing 的性能相当有竞争力。我们在图 7 中重现了这些实验的结果，其中各种操作是在负载因子为 $1/3$ 的情况下进行的。需要注意的是，对于小于 $2^{15}$ 的 $n$ 值，由于 CPU 缓存的影响，各种哈希表方案的运行时间非常相似。而对于超过该阈值的 $n$ 值，缓存未命中效应可能是导致不同方案运行时间差异的原因。
