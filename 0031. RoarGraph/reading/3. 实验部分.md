## 5 实验

本节介绍实验设置，评估RoarGraph与最先进的图索引方法的性能对比，并进行消融实验分析。

### 5.1 实验设置

**数据集。** 实验使用了表1中列出的三个现代大规模跨模态数据集进行评估：

1. **Text-to-Image [14]** - 这是一个流行的基准数据集，其中查询分布与基础数据不同，包括由Se-ResNext-101模型 [29]（DSSM模型 [30] 的变体）生成的图像和文本查询向量。相似度评估基于内积计算，称为MIPS（最大内积搜索），内积值越大表示关系越紧密。
2. **LAION [58]** - 包含数百万对图像-替代文本（Image-Alt-Text）对，作为向量搜索基准数据集 [70] 使用。图像和文本的嵌入向量由高级模型CLIP-ViT$B/32$ [59]生成，相似度测量采用余弦距离。
3. **WebVid [5]** - 包含从素材网站获取的字幕和视频对，其相似度基于余弦距离计算。本文使用的WebVid嵌入向量是由CLIP-ViT-B/32编码的帧嵌入 [39]。

在实验中，Text-to-Image使用[14]的官方1万条向量作为查询集，而LAION和WebVid则分别从原始数据集中采样1万条文本向量进行评估。此外，每个数据集中还提供了大量与查询集不重叠的文本向量，用于索引构建。

---

**算法和参数设置。**

在评估中选择基于图的方法作为基线算法，因为它们表现出色 [44]。HNSW [52]和NSG [20]因其搜索效率广受认可。最近的$\tau$-MNG [56]通过在接近节点之间建立额外的连接，在ID-ANNS中实现了最先进的Recall@100性能。此外，RobustVamana [34]（第3节介绍）是唯一专门为OOD查询设计的索引。

我们根据官方说明和经验实验，为所有算法设置了最佳参数：

- **HNSW [52]**：将$M$从8调整到48，最终设置$M=32$来控制节点的出度，efConstruction设为500。
- **NSG [56]**：将度数限制$R=64$，设置$C=L=500$以提供高质量的邻居。
- **$\tau$-MNG [56]**：$\tau$-MNG与NSG共享内部参数$R, C, L$，分别设置为64, 500, 500。根据其论文建议，将参数$\tau$从0.01调整到0.3，并最终在所有数据集上将$\tau$设置为0.01以获得最佳性能。
- **RobustVamana [34]**：将$R=64, L=500$，并将$\alpha$从1.0调整到1.2，最终设置为$\alpha=1.0$。查询数量与基础数据规模一致，用于索引构建以获得最佳性能。
- **RoarGraph（本文提出）**：设置$N_{q}=100$控制二分图连接，$M=35$和$L=500$用于邻域感知投影和连通性增强。与RobustVamana类似，使用与基础数据规模相同的查询数量构建索引。

所有算法均使用官方代码构建索引并执行搜索。RoarGraph采用C++实现，所有源代码均使用GCC 10.5.0编译，并启用-O3优化。

---

**性能指标。**

参考以往研究 [19, 20, 50, 52, 75]，我们使用**recall@k**（定义见第2.1.1节）来衡量检索的准确性，并在评估中报告所有查询的平均recall@k。

此外，我们采用每秒查询数（QPS），这在单线程场景中等同于**延迟**，用于衡量搜索速度 [19, 20, 22, 52, 56, 75]。

为了全面验证各方法在不同检索场景下的有效性，我们在评估过程中将$k$的取值设置为1、10和100。

------

实验在一台配备双$\operatorname{Intel}(\mathrm{R})$ Xeon(R) Gold 5318Y CPU和512 GB内存的机器上进行，操作系统为Ubuntu 20.04。

为确保公平比较，所有算法均在**单线程模式**下运行，因为部分方法的官方实现不支持多线程。

### 5.2 搜索速度与召回率

图11报告了QPS与召回率的结果。传统的图基方法（如HNSW、NSG和$\tau$-MNG）是针对ID搜索设计的，在跨模态ANNS中的OOD工作负载表现较差。

作为专门针对OOD任务的解决方案，RobustVamana在LAION和WebVid数据集上针对recall@1和recall@10的性能优于三种ID索引方法。然而，本文提出的RoarGraph在所有召回率范围内（当$k$在recall$@k$中变化为1到100时），在三个跨模态数据集上始终优于所有最先进的图索引方法。

具体而言，当recall@10 $\geq 0.9$时，RoarGraph在Text-to-Image、LAION和WebVid数据集上分别比最有效的图索引加速了$1.84 \times, 2.58 \times$和$3.56 \times$。在$k=1$和$k=100$的情况下也观察到类似的性能提升。此外，RoarGraph在LAION和WebVid数据集上能够达到recall@100 $\geq 0.99$甚至更高的水平，这是其他任何图索引算法都难以实际实现的。

------

这一观察结果验证了第3节中的分析和动机。在三个传统图算法中，HNSW和NSG表现相似，而最新的索引$\tau$-MNG [56]在跨模态数据集上的性能较低，尤其是在$k=1$和10时表现更差。

这主要是因为$\tau$-MNG基于NSG添加了更多边来连接节点周围的近邻。然而，根据我们的分析，OOD查询的最近邻并不像ID查询那样聚集分布。真实标签往往分布较广，因此$\tau$-MNG通过连接较近节点提高连通性的策略对搜索效率贡献不大，反而增加了计算负担。

### 5.3 路由跳数与召回率

在基于图的索引中，实现目标召回率所需的跳数是搜索效率的另一项衡量指标。搜索过程中，每次跳跃都会产生一定的计算成本，用于检查图中邻居节点。跳数越少通常表示搜索路径越短，从而提高搜索效率 [35, 44]。

在图12中，我们评估了束搜索过程中三种典型图索引（HNSW、RobustVamana和RoarGraph）的跳数情况。

结果显示，与HNSW和RobustVamana相比，RoarGraph在三个数据集上的搜索跳数显著减少。例如，当recall@10 $\geq 0.90$时，RoarGraph的跳数分别降至以下比例：

- 相较于HNSW：减少$44.1%, 21.0%$和$10.9%$；
- 相较于RobustVamana：减少$53.1%, 54.7%$和$41.1%$。

随着召回率@k的增加，这些比例逐渐降低，进一步强调了RoarGraph在跨模态查询中建立了有效的边连接，从而优化了导航路径和搜索效率。

### 5.4 消融实验

我们进行了对比评估，以验证RoarGraph构建过程中各项技术的有效性。参与实验的包括在RoarGraph生成之前创建的**查询-基础二分图**和**投影图**，分别表示为$G_{bi}$和$G_{pj}$，它们均可用于查询。

评估时采用**QPS-召回率**指标，而不是**跳数-召回率**。这是因为，与具有类似度数限制的HNSW和RoarGraph比较不同，二分图必须保持查询节点的较高出度，这导致每跳访问的节点数量远多于$G_{pj}$和RoarGraph。因此，在比较$G_{bi}, G_{pj}$和RoarGraph时，跳数的减少无法匹配QPS提升所反映的改进。

例如，在LAION数据集上：

- 查询跳数$\geq 100$时，访问的节点数分别为10507、2426和3494；
- recall@10分别为0.918、0.906和0.937，对应查询-基础二分图、投影图和RoarGraph。

这些统计结果表明，$G_{bi}$需要每跳访问更多的节点。此外，这也验证了投影图得益于**邻域感知投影**（Neighborhood-Aware Projection）技术，有效降低了节点度数，并在处理OOD查询时表现出贪婪路由导航能力。投影图仅访问2426个节点，即可在约100跳内实现recall@10=0.9。

**连通性增强（Connectivity Enhancement）**通过增加补充边提升了节点的度数，提高了图的可达性和连通性。我们认为它引入了更多可选路径，有助于缩短搜索路径，并在高召回率条件下增强搜索精度。

------

图13中的性能评估结果表明，二分图在三个数据集上的表现最差，这与分析一致。而**投影图**通过**邻域感知投影**在所有召回率范围内实现了数倍加速。

我们观察到RoarGraph在Text-to-Image数据集上比投影图快$1.49 \times$，但在LAION和WebVid数据集上，当recall@10 $\leq 0.86$时，投影图表现出更高的效率。

这一现象归因于**连通性增强**增加了节点度数。在低召回率条件下，这些补充边引入了额外的计算开销，但在高召回率条件下，它们在寻找有效路径和收敛方面发挥了重要作用。

### 5.5 查询集规模对索引的影响

为了评估RoarGraph对索引构建中查询数量 ($|\mathcal{T}|$) 的敏感性，我们通过调整系数$p$使$|\mathcal{T}|=p \times|\mathcal{X}|$，并将查询集表示为$\mathcal{T}_{p}$，测试QPS与召回率之间的权衡。

------

图14展示了在索引构建过程中，不同查询集规模与召回率之间的关系。评估设置$p$为基础数据规模的$10%$、$50%$和$100%$。

结果显示，在RoarGraph构建过程中使用$\mathcal{T}*{0.5}$可以在所有数据集上获得与使用$\mathcal{T}*{1}$相当的性能表现（recall@10和recall@100）。

尽管查询集规模减少会导致性能下降，但使用$\mathcal{T}*{0.1}$构建的索引在实现recall@$100 \geq 0.95$时仅比$\mathcal{T}*{0.5}$构建的索引慢$11.3%, 12.9%$和$29.2%$。

更重要的是，实验结果表明，即使仅使用$\mathcal{T}_{0.1}$构建RoarGraph，依然保持卓越的效率，在达到recall@10 $=0.9$时，相比HNSW提高了$1.44-4.38 \times$的性能。

------

### 5.6 面向分布内查询的鲁棒性

除了在OOD-ANNS中表现优异之外，一个ANNS索引还需要有效处理分布内（ID）查询，以便在应用中同时支持不同类型的查询。因此，我们在实验中使用ID查询作为工作负载，对单模态ANNS进行对比分析。

对于三个数据集，每个ID查询包含从原始大规模数据集中抽样的1万条视觉嵌入向量。

------

如图15所示，RoarGraph在ID工作负载下表现出较强的鲁棒性，并在三个数据集上展现出与HNSW相当的效率。

尽管RobustVamana整体上比RoarGraph和HNSW速度更慢，但在LAION数据集上达到了recall@10 $\geq 0.995$，而HNSW和RoarGraph均未能达到这一水平。

### 5.7 索引大小与构建开销

图16比较了索引大小和索引构建的开销。最终的索引大小反映了搜索阶段的内存消耗。

如图所示，RoarGraph的索引大小在Text-to-Image、LAION和WebVid数据集上分别消耗了9.04 GB、20.64 GB和5.07 GB——仅略大于NSG。这表明RoarGraph在保持较小内存开销的同时，显著提升了跨模态ANNS的性能。

------

在索引构建开销评估中，我们为所有图索引算法使用了64个线程。

我们对比了RoarGraph在两种查询向量集规模下的构建时间：$100 %$ 和 $10 %\left(\mathcal{T}*{1}\right.$ 和 $\left.\mathcal{T}*{0.1}\right)$，分别相对于基础数据量。

- HNSW在所有数据集中表现为构建时间最短的索引。
- NSG和$\tau$-MNG需要构建近似最近邻图，这增加了构建时间。

具体来说：

- 在使用$\mathcal{T}_{1}$构建RoarGraph时，构建时间比RobustVamana长1.12到3.02倍，比NSG长1.7到7.5倍，比HNSW长4.8到17.5倍。然而，在WebVid上，RoarGraph比$\tau$-MNG快$21%$。
- RoarGraph的预处理阶段（计算查询向量的真实标签）占总构建时间的$87 %$到$93 %$（基于$\mathcal{T}_{1}$）。

------

使用$\mathcal{T}_{0.1}$构建时，RoarGraph的构建时间大幅减少：

- 仅需$\tau$-MNG构建时间的$16 %$到$54 %$；
- 仅需NSG构建时间的$35 %$到$98 %$；
- 在Text-to-Image和LAION数据集上，构建时间仍然是HNSW的两倍，但在WebVid数据集上，与HNSW的构建时间相当。

在这种情况下，预处理阶段占总构建时间的比例分别为：

- Text-to-Image：$67%$；
- LAION：$73%$；
- WebVid：$43%$。

------

综上所述，使用$\mathcal{T}_{0.1}$构建的RoarGraph仍然提供了显著的搜索性能提升（参见第5.5节），同时大幅减少了构建时间。这使得应用程序可以在**构建成本**和**搜索效率**之间进行权衡，使其成为一个灵活且实用的选择，适用于不同场景。

## 6 讨论

**RoarGraph 在实际场景中的构建。**

RoarGraph 的核心理念是有效利用跨模态查询向量来构建图索引，从而显著提升跨模态向量搜索性能，并可应用于以下实际场景：

------

大型基于嵌入的检索和推荐系统（如 Bing [71]、YouTube [12]、Amazon [8, 40, 82]、TikTok [23, 48]、Pinterest [27] 等）通常拥有大量的历史查询数据。因此，作为一种工作负载驱动的跨模态ANNS索引，RoarGraph可以充分利用这些历史查询向量来构建索引。此外，此类应用还可以利用其多模态深度学习模型（为基础数据和查询生成嵌入）对大规模（多达十亿级）的公共真实数据集 [5,53,60,61] 进行编码，以便在需要时补充数据。

在查询数量有限的情况下，RoarGraph 仍然能够显著提升性能（详见第5.5节）。

------

**RoarGraph 的更新机制。**

在索引构建过程中，查询-基础二分图会被保存下来，以便支持RoarGraph的离线插入功能。

插入过程如下：

1. 将新的基础数据向量$v$视为查询，通过RoarGraph搜索其近似最近邻。
2. 仅返回由至少一个查询节点$q$连接的基础节点作为结果。
3. 如果多个查询节点符合条件，则选择距离$v$最近的$q$。

接下来，利用$q$的外邻居$N_{\text {out}}(q)$，将$v$和$q$整合为子二分图$\left(N_{\text {out}}(q) \cup q \cup v\right)$。随后，对该子二分图应用**邻域感知投影（Neighborhood-Aware Projection）**，以$v$作为中心点生成投影图，并将新向量$v$相关的边合并到RoarGraph中完成插入操作。此外，二分图会更新$v$，将其加入$q$的外邻居，为后续插入铺平道路。

该插入策略避免了在二分图中计算新数据与查询节点之间精确距离的高成本。使用64线程时，在LAION数据集中插入200万个基础数据向量仅耗时583秒，这仅占重建索引时间的7%。

------

我们在不同插入数量下对索引进行了评估，并与重建索引进行了对比。插入的数据量按数据集规模的1-20%进行调整。

图17显示，通过此插入策略更新的RoarGraph索引在性能上与重建索引具有竞争力。例如：

- 在Text-to-Image和LAION数据集上，处理200万个向量插入后，当recall@10=0.95时，RoarGraph相较重建索引分别下降约13%和10%的性能。
- 在WebVid-2.5M中，插入50万个向量后，recall@10=0.95的QPS下降约17%。

------

**关于删除操作。**

RoarGraph 使用墓碑标记法（tombstones）标记删除点 [56, 79]。被删除的点仍参与路由，但不会出现在搜索结果中。

------

**当前更新机制的挑战：**

1. 在处理连续大规模插入时，后续构建的二分图对近邻关系的近似程度可能低于重建的索引。
2. 墓碑标记法需要随着更新的累积进行周期性重建 [56]。

上述挑战表明，插入和删除方法仍需在未来工作中进一步探索和优化。

## 7 相关工作

关于近似最近邻搜索（ANNS）的研究文献非常丰富。除了前文介绍的方法之外，还有一些研究利用查询来提升基于图的ANNS性能。

在文献 [43] 中，束搜索的终止条件被定义为二元分类任务，并利用查询训练分类模型来判断何时终止搜索。

文献 [6] 将图卷积网络（GCN）引入ANNS，通过从大量训练查询中学习来发现最优的搜索路由路径。此外，文献 [18] 将强化学习与GCN相结合，以引导基于邻近图的搜索路由。

另一项研究GraSP [84] 采用概率模型和子图采样，从查询分布中学习边的重要性得分，并在图索引中修剪边。然而，这些基于学习的方法在索引构建阶段需要昂贵的训练和调整过程。

------

在推荐系统中，文献 [69] 利用神经网络进行相似度排序，并通过二分图连接用户和物品，在二分图上执行搜索。该研究指出，在物品向量或用户向量之间没有定义相似度度量，因此边只能建立在两类节点之间。这种情况与跨模态检索不同，因为跨模态检索可以评估不同基础向量或查询向量之间的相似度。

------

ScaNN [26] 结合向量量化（VQ）[25]和乘积量化（PQ）[36]，使用各向异性损失进行分区和压缩。同时应用优化技术，例如标量量化、重新评分以及SIMD寄存器内PQ查找 [1]，以实现快速搜索。

------

关于基于图的ANNS方法，还有几项理论分析研究 [19, 20, 56, 57, 64]。这些研究推导了图索引搜索过程的时间复杂度，并假设查询与基础数据遵循相同分布。然而，当应用于跨模态ANNS时，这些理论分析面临较大挑战。

------

## 8 结论

跨模态数据检索是重要的工作负载之一。本文对OOD查询进行了深入分析。我们发现，在高维嵌入空间中，OOD查询的k-最近邻之间彼此距离较远。这是现有ANNS方法效率低下的根本原因，因为该特性破坏了现有设计中的假设条件。

为此，我们提出了**RoarGraph**——一种高效处理OOD-ANNS的图索引，该索引基于查询分布指导构建。

大量实验结果表明，RoarGraph在跨模态向量搜索中表现出卓越的性能。

