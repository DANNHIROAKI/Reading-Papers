## 3 跨模态ANNS中OOD工作负载分析

本节对分布外（OOD）工作负载进行了分析，以深入理解现有方法在跨模态ANNS中难以实现高性能的原因。

### 3.1 基本差异

通过深入实验和分析，我们发现分布外ANNS（OODANNS）与分布内ANNS（ID-ANNS）之间存在==两个关键差异==。

---

**OOD查询距离其最近邻较远。** 在图4中，我们计算了查询与其最近邻$(\mathrm{k}=1)$之间的距离，表示为$\delta\left(q, i^{t h} N N\right)$。其中$q$表示查询，$\delta(\cdot, \cdot)$为数据集的距离度量函数。

从图中可以观察到，OOD查询与其最近邻之间的距离显著大于分布内查询与相同基础数据中真实标签之间的距离，即在ANNS背景下，$\delta\left(q_{o o d}, i^{t h} N N_{o o d}\right) \gg \delta\left(q_{i d}, i^{t h} N N_{i d}\right)$。

尽管存在极端值，但考虑中位数数据，OOD查询与最近邻之间的距离分别比ID查询远2.1倍、5.3倍和11.3倍。此外，我们还发现偏离的OOD查询会导致其$k$最近邻在高维空间中彼此距离较远，而ID查询的最近邻通常彼此靠近。

为验证OOD查询的$k$最近邻之间的空间分离程度，在$\mathrm{k}=100$的场景下，我们计算给定查询$q$的$i^{t h} N N(i=1 \ldots 100)$与其余99个最近邻之间的平均距离，共生成100个距离值来衡量查询$q$最近邻之间的分离程度。随后，通过所有查询的$i^{t h} N N$距离平均值反映这一特性。

图5展示了这一现象：OOD查询的最近邻之间的距离明显大于ID查询的最近邻，在三个数据集上分别高出1.29倍、1.45倍和2.11倍。这一发现表明，在OOD查询的前$k$个答案之间存在大量噪声数据向量。

:one:$\text{OOD}$查询的特性

1. $\text{OOD}$查询与其最近邻距离很远
   - 实验证明，其距离是$\text{ID}$查询到最近邻的$2-11$倍
2. $\text{OOD}$查询的最邻近之间相互距离也很远
   - 实验证明，$\text{OOD}$查询$\text{100}$个最邻近相互的平均距离，是$\text{ID}$查询的${1.5-2}$倍

---

为了说明这一反直觉的现象，我们在图6中展示了一个示例。基础数据用灰色点表示，围绕一个三维球面附近波动。一个分布内（ID）查询（绿色菱形）位于球面附近，并且被两个距离较近的最近邻（绿色点）所包围。而一个分布外（OOD）查询（红色方块）则远离球面表面，位于半球的某一区域内。两个蓝色点深陷于球体内部，彼此之间距离较远，但却成为OOD查询的最近邻。

------

图7展示了来自LAION数据集的真实示例。该图基于LAION数据集的500个数据点子集，通过K-means算法聚类成40个中心点生成。分别从ID查询和OOD查询中抽取三个示例，并计算每个查询的五个最近邻。然后使用主成分分析（PCA）[28]对10万个点进行降维处理，将数据降至二维进行可视化，并使用采样的500个向量计算Voronoi单元。

从结果中可以明显看出，ID查询的五个最近邻集中在相对靠近的Voronoi单元中。而OOD查询的五个最近邻在图中表现出显著的分散性，$5-\mathrm{NN}$落在彼此分离的Voronoi单元中。这进一步说明了OOD查询的最近邻在空间上具有较大分布间隔的特点。

### 3.2 Why Previous Methods Fail on OOD-ANNS

现有方法低效的主要原因在于，分布外（OOD）查询破坏了传统ANNS方法所依据的假设。当前最先进的ANNS索引背后的核心假设包括：

1. 查询与基础数据中的向量距离较近，假设查询与基础数据遵循相同的分布 [20,44,56]；
2. 查询的$k$个最近邻在空间$\mathbb{R}^{D}$中彼此靠近，或者某个邻居的邻居也很可能是查询的邻居 [16,20,44,56,57,64]。

基于这些假设，图基方法通常采用束搜索（beam search）来构建近似$k$最近邻图，并执行搜索操作 [19,20,43]。因此，这些方法将空间上相近的向量转换为图中紧密连接的节点，并进一步假设束搜索可以通过贪婪路由，在每一步逐步收缩搜索空间，高效地定位包含真实标签的搜索范围 [20,56,57]。

:one:传统$\text{SOTA-ANN}$的两个假设

1. 查询和数据同分布

2. 查询得到的$k$个最近邻彼此相互靠近

:two:传统图$\text{ANN}$的设计

1. 用$\text{BeamSearch}$来构建$\text{KNN}$图，空间中相近的点转化为图中紧密连接的结点
2. 用$\text{GreedySearch}$来在图上搜索

---

然而，对于OOD查询，搜索空间会显著扩大。考虑一个高维球体$B^{k}\left(1^{s t} N N, R\right)$，其中心为给定查询的第一个最近邻$1^{s t} N N$，半径$R$定义为该查询中所有最近邻之间的最大距离$\delta\left(i^{t h} N N, j^{t h} N N\right)$（其中$i \neq j$）。在图索引中，包围当前访问节点$x$的球体$B^{s}(x)$以及$B^{k}$构成可识别的搜索空间 [20,56]。

从图5可以观察到，$R_{\text {ood }}$远大于$R_{i d}$，其范围为$1.29 \times$到$2.11 \times$。假设球体体积表示为$C_{B} \times R^{D}$，其中$C_{B}$是固定维度$D$的常数，则高维空间中$R_{o o d}^{D} / R_{i d}^{D}$的比值会显著增加，这导致$B_{o o d}^{k}$的规模远大于$B_{i d}^{k}$。

与此同时，搜索空间$B^{s}(x)$会大幅扩张，并由于$B^{k}$的膨胀而难以高效缩小。对于OOD查询，其分散的最近邻会成为贪婪路由中的局部最优陷阱，导致搜索收敛困难。这表明，处理OOD查询需要访问大量节点。

==为何$\text{ODD}$会导致搜索空间增大==

:one:搜索空间的定义：

1. 球体：$B^{k}\left(1^{\text{st}}\text{-NN}, R\right)$
   - 球心：$\text{Top-1}$离近点，也就是$1^{\text{st}}\text{-NN}$ 
   - 半径：所有$k$临近点互相之间，距离的最大值$R\text{=}\delta\left(i^{\text{th}}\text{-NN}, j^{\text{th}}\text{-NN}\right)$ 
2. 可识别搜索空间：
   - 以当前结点$x$为中心的球形区域$B^{s}(x)$
   - 最邻近所在区域，就是上述的$B^k$ 
3. 搜索的目的：迭代$x$，让$B^{s}(x)$与$B^k$ 逐渐重叠

:one:$\text{OOD}$导致空间膨胀

1. $B^k$ 大幅扩张
   - 由于最邻近之间相互远离，导致$R_{\text {ood }}$远大于$R_{i d}$
   - 由此造成的体积比$\left(\cfrac{R_{\text {ood }}^D}{R_{i d}^D}\right)$更巨大
2. $B^{s}(x)$也会膨胀，并且由于最邻近分散，更容易陷入局部最优

------

为了进一步说明在搜索OOD查询时收敛的困难性，假设基于图7的数据构建了一个常用的图索引，其中距离较近的向量倾向于在图索引中相互连接。

对于ID查询，由于最近邻（蓝色六边形）彼此距离较近，沿着搜索路径$B^{s}(x)$可以轻松收缩。每次贪婪路由的推进都会将搜索空间收缩到包含ID查询最近邻的小球内 [20,56,57]。

然而，对于OOD查询，束搜索在单一方向上难以收敛。当路由到$k$个最近邻之一（红色菱形）时，即便搜索已到达某个近邻，搜索空间仍无法有效收缩。这是因为与ID查询相比，OOD查询的真实标签在一个更大的球体内分布。

为了获得较高的召回率，处理OOD查询的搜索过程需要更大的束宽、更长的搜索路径，以及在搜索过程中增加的计算和内存访问，以避开局部最优陷阱并找到分散的答案。这最终导致了性能下降。

:one:$\text{ID}$查询的特点：每次移动都能缩小搜索范围

```txt
起点 -> 近邻1 -> 近邻2 -> 近邻3 (一个小范围内)
```

:two:$\text{OOD}$查询的困境：即使找到了某个近邻，其它最邻近也在完全不同的方向，使得搜索空间难以收缩

```txt
       近邻2
      ↗     
起点 -> 近邻1   近邻3 (分散在大范围内)
      ↘     
       近邻4
```

1. 需要更多的$\text{Beam}$宽度，以保证可以搜索更多的方向
2. 搜索的路径更长

3. 需要避开局部最优

---

基于空间划分的方法（例如IVF）在处理OOD查询时同样表现不佳。该类方法通过在基础数据上运行K-means算法获取聚类，其中距离较近的点被分配到同一聚类中。然而，对于OOD查询，其最近邻可能分布在分散且相距较远的聚类中。

对于OOD查询，包含最近质心的聚类可能并不包含真实标签，因为OOD查询识别出的近邻往往是分散的。在真实示例（图7）中，基于划分的方法表现出明显的性能影响：要达到召回率Recall@5=1.0，OOD查询需要扫描5个聚类，而ID查询仅需扫描2个聚类，导致性能下降约2.5倍。

对于百万规模的数据集，这种负面影响会进一步恶化，如第2.3.1节所述。

==$\text{OOD}$在划分方法($\text{IVF}$)上表现也不佳== 

:one:$\text{IVF}$先将数据分为若干簇

1. $\text{ID}$查询：集中在少数几个相邻簇中
2. $\text{ODD}$查询：分散在多个不相邻簇中，需要扫描更多的簇，性能下降$2.5$倍

## 4 ROARGRAPH：一种高效处理OOD-ANNS的图索引

通过对OOD-ANNS低效性的揭示和深入分析，我们提出了**RoarGraph**——一种在查询分布指导下构建的图索引，用于在跨模态检索中提供高效的ANNS解决方案。

### 4.1 面向ANNS的查询引导索引：挑战

由于OOD工作负载的特殊特性破坏了现有ANNS方法设计中的假设，我们提出利用查询分布来指导图索引的构建。与基于较小距离连接基础节点的方法不同，我们的方法将从查询视角被认为相近的空间上相距较远的向量，转化为图索引中紧密连接的邻近节点。

基于这一目标，我们的方法利用查询来引导RoarGraph的构建。例如，我们使用来自原始十亿规模LAION数据集的图像标题嵌入向量，来构建支持LAION文本-图像搜索的RoarGraph。

:one:传统方法：完全忽略查询的分布特征，仅基于向量间的距离建立连接

:two:$\text{RoarGraph}$的核心：利用查询分布来指导索引构建

1. 原有：空间上很近的向量$\text{→}$图中紧密连接的点
2. 现在：空间上远但查询认为近的向量$\text{→}$图中紧密连接的点

:three:示例：在文本-图像搜索中，用图像标题的嵌入，来指导图的构建

---

为了有效利用查询分布来指导图结构的构建，**二分图**成为建模两种模态嵌入之间接近关系的合理选择。二分图在推荐系统中被广泛应用 [17, 27, 76]，其由两组节点组成，边仅连接不同组的节点，同组内的节点不相互连接。

在OOD-ANNS中，基础数据和查询可以被视为二分图中的两个不同节点集（基础节点和查询节点）。在这里，查询节点起到了关键作用，作为桥梁将基础数据中的最近邻与查询向量关联起来。此外，贪婪搜索可以在这样的二分图上执行：从一个基础节点出发，移动到其外邻居（查询节点），再访问这些查询节点的外邻居（基础节点），然后选择更近的基础节点继续搜索。

:one:二分图：两组不同的节点，边只能连接不同组的节点

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250102115331261.png" alt="image-20250102115331261" width=250 />  

:two:在$\text{OOD-ANNS}$中的应用：

```tct
基础节点集(Q)        查询节点集(B)
   Q1    -----------   B1
   Q2    -----------   B2
   Q3    -----------   B3
```

1. 连接基础结点$/$查询结点，表征二者的相关性
2. 即使基础结点相聚较远，也可通过连接共同的查询节点建立联系

:three:查询过程中，可以以查询节点作为中介，比如

```txt
B1 -> Q1 -> B2 -> Q2 -> B3
(基础节点 -> 查询节点 -> 基础节点)
```

------

尽管这种结构自然适合建模两种分布的接近关系并支持搜索，但要构建一个高效的ANNS图索引仍然面临以下挑战：

**(1)** 在二分图中有效建立基础节点和查询节点之间的边，以建模两种模态之间的邻近关系，并在ANNS中实现实际的贪婪路由，这是一项复杂的任务。简单地将两类节点的最近邻连接起来，可能会导致节点度数过高，从而损害搜索效率。

**(2)** 在二分图上进行搜索需要经过查询节点的遍历，而保持查询节点较高的出度（例如$\geq 100$）对于覆盖基础数据至关重要。然而，这会在每次跳跃时带来较高的开销，并增加沿路由路径访问的节点数量，从而降低搜索速度。

由于每次访问基础节点都涉及从主存储器加载向量数据到CPU，并计算其与查询的距离，这两个过程在节点访问操作中非常耗时 [10]。访问的节点越多，内存访问和计算负担就越重。因此，在保持可导航搜索路径的同时，需要进一步降低节点的度数。此外，二分图由于包含两种节点类型和边，导致内存消耗进一步增加。

**(3)** 当利用查询引导图结构构建时，会出现基础节点可达性和连通性方面的局限性。仅依赖二分图中查询节点的外邻居来覆盖整个基础数据变得具有挑战性，这可能导致孤立节点或组件的出现，从而影响搜索效率。

==面临的挑战==

:one:边的建立：如何连接两类结点，暴力地将查询结点与其所有最近邻基础节点连接，会过于稠密

:two:搜索效率：​查询结点需要极高的出度来覆盖基础结点，但这会导致跳跃开销$/$内存占用变大

:three:连通性：极可能会出现孤立结点，或者独立子图

### 4.2 设计与实现

**4.2.1 概述。**
 RoarGraph旨在解决上述挑战，并在跨模态ANNS中提供卓越的性能。RoarGraph的构建过程可分为三个步骤，如图8(c-e)所示。

------

在初始步骤中，我们利用**查询-基础二分图**（图8(c)）将查询（查询节点）和基础数据（基础节点）统一到同一数据结构中。在构建二分图之前，会在预处理阶段计算查询向量的真实标签（图8(a)）。

随后，我们为每个查询建立与其$N_{q}$个最近邻的边，并在限制条件下从基础节点向查询添加边，即仅允许其内邻居中最接近的基础节点链接到查询节点（图8(c)中的蓝色箭头）。这种方法实现了两个主要目标：

1. 在查询与基础数据之间创建接近关系的映射；
2. 降低基础节点的出度，从而提高二分图上的搜索效率，==解决挑战1==。

==$\text{RoarGraph}$第一步：构建查询-基础二分图== 

:one:预处理阶段：计算每个查询向量的真实标签

```txt
查询Q1 -> 最相关的基础数据点{B1, B2, B3...}
查询Q2 -> 最相关的基础数据点{B4, B5, B6...}
```

:two:建边策略

1. 查询结点$\text{→}$基础结点：查询结点连接与其最近的$N_q$个基础结点
2. 基础结点$\text{→}$查询结点：基础结点连接与其最近的$1$个查询结点
   - 降低基础节点的出度，防止过于稠密

------

其次，我们提出了一种名为**邻域感知投影**（Neighborhood-Aware Projection）的技术，以将二分图有效地投影到基础数据上。在投影之前，为每个节点施加度数限制。对于每个查询节点，我们选择一个已连接的基础节点作为中心点（pivot），从对应查询节点的外邻居中选择邻居。

选择最接近中心点的节点后，按距离逐步选择更远的节点。通过**邻域感知投影**，我们移除了查询节点，但在投影图中保留了从查询分布中获得的邻近关系（图8(d)）。

这种方式降低了图的平均度数，使得投影图变得可导航 [20,52]。因此，在搜索过程中减少了需要访问的节点数量，==从而解决挑战2==。

==$\text{RoarGraph}$第二步：邻域感知投影== 

:one:基本目标：

1. 将二分图转化为只包含基础结点的图
2. 在这一过程中保留从查询分布获得的邻近关系

:two:实现方式：邻域感知投影

1. 遍历每个查询结点：

   ```txt
   查询Q ---> {B1, B2, B3, B4, B5}  (Q连接了5个基础节点)
   ```

2. 选择中心点：从与查询结点的基础结点中选择单个中心点

   ```txt
   查询Q ---> {B1, B2, B3, B4, B5}  (Q连接了5个基础节点)
               ↑
             pivot
   ```

3. 将所有基础结点，按照与中心点的距离排序

   ```txt
   与B1的距离：
   B2: 距离0.2
   B3: 距离0.4
   B4: 距离0.7
   B5: 距离0.9
   ```

4. 开始投影：让中心点$B_1$与余下基础点建立连接

   ```txt
   B1 ---> B2 (最近)
   B1 ---> B3 (次近)
   B1 ---> B4 (较远)
   B1 ---> B5 (最远)
   ```

   - 这一过程有度数限制，如果$B_1/B_2/B_3....$超过的度数，则拒绝连接

:three:这一过程得到意义：移除了查询结点，但又保留了查询集中的临近关系

------

在最后一步中，我们对投影图应用**连接性增强**（Connectivity Enhancement）技术，以解决孤立节点、分离图组件以及节点之间可选路径不足等问题（解决挑战3）。

具体而言，我们使用束搜索遍历投影图中的每个节点，并在额外的度数预算下将邻近节点作为补充邻居加入到每个节点中。

这一过程提高了图的连通性和可达性，从而完成RoarGraph索引的构建（图8(e)）。

随后，我们将详细介绍设计原理以及每项技术优化的具体内容。

==$\text{RoarGraph}$第三步：连接性增强== 

:one:需要解决的问题：孤立的结点，互不连通的子图，节点间路径太少

:two:解决的办法：

1. 使用束搜索遍历每个节点
2. 如果某结点度数未超支，则添加新的最邻近作为邻居

---

**4.2.2 查询-基础二分图。**

我们构建了查询-基础二分图，该图作为统一的容器，用于在基础数据和查询的分布之间建立邻近关系映射。在二分图中，查询$(\mathcal{T})$和基础数据$(\mathcal{X})$分别作为两种不同类型的节点：查询节点和基础节点。需要建立两种有向边：

1. 从基础节点到查询节点的边；
2. 从查询节点到基础节点的边。

==查询-基础二分图的基本结构==

:one:两类节点：查询结点，基础节点

:two:两种边：查询结点$\text{→}$基础结点，基础结点$\text{→}$查询结点

------

首先，为了构建能够从查询视角识别基础数据邻近关系的二分图，我们从查询节点到基础节点建立边。具体而言，从每个查询节点向其在基础数据中的$N_{q}$个最近邻（基础节点）添加有向边。

维持查询节点较高的出度（图8(b)中$N_{q}=3$）是至关重要的，主要原因包括：

1. 扩大基础数据的覆盖范围，并通过查询充分建模基础数据中的邻近关系；
2. 确保查询的外邻居具有重叠性，使得在搜索过程中二分图内的大多数基础节点可达。

==查询结点$\text{→}$基础结点的建边策略==

:one:查询结点$\text{→}$基础结点的建边策略：查询节点$T_1\xrightarrow{连接}$最近的$N_q\text{=}3$个基础节点

:two:为何要保持查询结点的高出度($N_q$更大)

1. 扩大对基础数据的覆盖范围
2. 确保查询的外邻居具有重叠性，即让两个基础节点可以通过共同连接的查询节点找到彼此

------

其次，为了将基础节点连接到查询节点，我们尝试了一种简单策略：将现有的有向边转换为双向边，从而为基础节点分配度数$d=N_{q}$。然而，这种方法需要在二分图搜索的每一步检查邻居的邻居（$N_{q}^{2}$个节点），如4.1节所述，效率较低。

因此，我们提出了一种更实用的策略：为每个查询节点保留$N_{q}$个指向最近邻的链接（见算法1，第3行），并降低$d$以优化效率。

与我们的设计目标一致，即最小化$d$并建模邻近关系，我们选择每个查询节点的$N_{q}$个外邻居中最近的基础节点$x$，并从$x$向其对应的查询节点添加一条边。这一策略将$d$降低到1，并完成二分图的构建。同时，我们移除查询节点到$x$的链接，即算法1中第4-6行的$t_{c} \rightarrow x$。

==基础结点$\text{→}$查询结点的建边策略==

:one:最初的尝试：直接把原有的连接，从单向变为双向

- 弊端在于：每次检索需要检查$N_q^2$个结点

:two:改进后的策略：仅选择基础结点中最近的进行反向连接，反向连接后删除原有正向的边

1. 原有

   ```txt
   T1 --> X1, X2, X3 (Nq=3)
   ```

2. 最初方法

   ```txt
   T1 --> X1, X2, X3
   T1 <-- X1
   T1 <-- X2
   T1 <-- X3
   ```

3. 改进方法

   ```txt
   T1 --> X2, X3 
   T1 <-- X1
   ```

:three:改进的意义：基础接结点的出度降维$1$，以提高搜索效率

------

图8(b-c)展示了查询-基础二分图的构建过程。在示例中，当$N_{q}=3$时，二分图中每个查询节点有两个外邻居，而其他基础节点的出度为1。

在图8(c)中，节点C作为算法1中查询节点$Q_{1}$的$x$。节点G由于度数限制和与查询节点的接近性不足而被隔离，这种现象在真实数据集 [5, 14, 61] 中经常出现。

---

**4.2.3 邻域感知投影（Neighborhood-Aware Projection）。**

尽管查询-基础二分图在内存消耗方面较高，我们发现在该二分图上进行搜索效率较低。这是因为通过查询节点的路由需要较长的搜索路径，并且沿搜索路径访问的节点过多（每跳大约访问$N_{q}$个基础节点）。

为了解决这一问题，我们提出将二分图投影到基础节点上。虽然一种直接的二分图投影方法可以完全连接共享共同邻居的节点 [87]，但由于无法满足降低节点度数的目标，该方法不适合用作图索引。因此，我们提出了一种**邻域感知投影**方法，以在删除查询节点的同时保留查询节点识别出的基础节点邻域关系。

在图8(d)中，图被投影后，查询节点的外邻居与中心节点（pivot）$\mathrm{C}, \mathrm{D}$和$\mathrm{E}$相连。由于度数限制，边$D \rightarrow B$和$F \rightarrow D$未被建立。

:one:二分图的缺陷：内存消耗高(额外存储了查询节点)，搜索路径长(需要额外经过查询结点)

- 解决办法：将二分图投影到基础节点上

:two:直接投影：将共享同一查询结点的基础结点，全部互相连接

- 还是老问题，结点度数太高了

:three:邻域感知投影的方案：

1. 照样是先找到：一个查询结点的所有基础结点
2. 改进的点：
   - 不全部连接，而是先确定一个$\text{Pivot}$，再让余下点与这个$\text{Pivot}$连接
   - 并且不满足度数限制的边也不连接

------

我们在图9中说明了投影过程。查询节点作为桥接节点（绿色节点），其输入邻居被指定为**中心点（pivot）**（节点P），负责在投影过程中选择其邻居。当前投影中过滤掉了大量靠近但无关的灰色节点。

对于每个中心点，其桥接节点的外邻居成为中心点的潜在邻居（注意：基础节点的邻居的邻居也是基础节点）。这些潜在候选节点表示查询的最近邻，但彼此之间距离较远（如第3节所示）。这些候选节点被放入一个容量为$L$的候选队列中，并按到中心点的距离进行排序（算法2，第5-6行）。

接下来，从队列中选择最接近的节点作为中心点的外邻居（算法3，第2行；图9(b)），然后从候选队列中为每个中心点选择最多$M$个邻居以满足度数限制。

邻居选择的核心思想是：如果候选节点到现有邻居的距离小于到中心点的距离，则该候选节点将被排除在中心点的外邻居列表之外（算法3，第4行）。

:one:投影过程

1. 让查询结点$P$作为桥接结点，与一系列基础结点$\{X1,X2,X3,...\}$相连，从中选择一点$P$作为$\text{Pivot}$
2. 计算$P$与余下基础节点$\{X1,X2,X3,...\}$的距离，并将$X_n$按照此距离排序构成候选队列
3. 从候选队列中最多选择$M$个最近的节点作为$\text{Pivot}$的邻居

:two:筛选规则：比如$\text{Pivot}$已经连接了$X$，对于$Y$的处理如下

<img src="https://raw.githubusercontent.com/DANNHIROAKI/New-Picture-Bed/main/img/image-20250102134330087.png" alt="image-20250102134330087" width=200 /> 

1. 如果$\text{Dist}(X,Y)\text{<}\text{Dist}(\text{Pivot},Y)$ ，则筛掉$Y$

---

这种策略包含了查询视角下较近但在空间上分散的候选节点，以便为基础节点建立有效路径。例如，在图9(c)中，我们观察到节点$Y$更容易通过节点$X$到达，而节点$Z$更难找到，因为$Y$相对更接近$X$，而$X$已连接到中心点P。因此，节点$X$和$Z$成为P的邻居，且符合度数限制。

为了最大限度地利用查询分布的信息，我们会在投影过程中，在$M$度数限制内尽可能填充外邻居（算法3，第8行）。例如，尽管节点$Y$之前被过滤掉，但在度数限制$=3$的填充操作中包含它，可以确保不会浪费度数预算。

在为每个中心点获取邻居后，我们还检查是否可以为其输入邻居建立反向链接（算法2，第9行）。

:one:度数填充策略

1. $P$有度数限制$M$，假设$P$经过上述过程连接了$M-1$个点，即还有一个度数没有用到
2. 你们比如即使$Y$之前被滤掉了，则也重新加回来

:two:反向链接检查：

1. 经过上述过程，$\text{Pivot}$有了一定的邻居
2. 检查所有$\text{Pivot}$的邻居是否可以建立反向连接，检查的标准为是否符合度数限制

---

**4.2.4 连通性增强（Connectivity Enhancement）。**

投影图虽然保留了查询分布的信息，但仅依赖于二分图的覆盖范围无法充分提供合适的可达性和连通性，这对贪婪路由至关重要 [20,57]。

如图8(d)所示，节点G被隔离，节点B不可达，而路径$A \rightarrow D$过长。这一问题在真实数据集实例中进一步得到了验证（见图10(a)），其中$7%$的节点被隔离，$20%$的节点度数小于或等于1。这意味着搜索过程无法访问这些节点，即使它们是查询的真实标签。此外，连通性薄弱可能导致搜索路径过长。

==为何要连通增强==

:one:投影图的局限性：效果不好，连通性差(对$\text{GreedySearch}$不友好)

------

为了克服这一限制并增强可导航性，我们对投影图$G^{\prime}$应用**连通性增强**（算法1，第10行），然后在最终步骤中合并$G^{\prime}$与$G_{pj}$中的边。

具体而言，从基础数据的**中心点（medoid）**开始，我们将基础向量视为查询，并针对每个节点执行束搜索（beam search），队列容量设为$L$。收敛后，它返回访问的$L$个节点作为结果。

每个基础节点通过算法3从其结果中获取补充邻居，同时尝试添加反向边（算法1，第12-14行）。

重要的是，这些补充邻居有助于远距离节点之间的OOD查询路由，因为这些边是基于投影图中的路径构建的。

:one:连通增强的流程

1. 一基础数据的$\text{Medoid}$为起点
2. 遍历每个基础结点，将当前基础节点作为查询，对整个基础数据集进行$\text{BeamSearch}$
   - 从结点的搜索结果中，选择结果作为邻居补充

------

如图8(c)所示，蓝色边将节点G包含到图中，使节点B变得可达，并缩短了节点之间的路径。例如，路径$\mathrm{A} \rightarrow \mathrm{D}$从4跳减少到3跳，路径$\mathrm{B} \rightarrow \mathrm{A}$从4跳减少到2跳。

图10(b)展示了连通性增强的效果，它增强了贪婪搜索的可导航性，使节点变得可达，并通过连接边减少了迂回路径 [20, 52]。

请注意，该图中忽略了边的方向，并且节点的布局并未准确反映实际几何关系，而仅用于展示图结构。

==连通性增强的具体效果==

### 4.3 RoarGraph上的搜索

贪婪路由是基于图的ANNS的常规搜索方法。作为一种通用图索引，RoarGraph同样采用**束搜索**（beam search）作为搜索算法。需要强调的是，现有的ANN索引优化和压缩技术 [1,9,22,36,36] 与RoarGraph是**正交的**，因此RoarGraph可以直接采用这些优化技术来进一步提升性能（如果需要）。

------

在搜索过程中，我们使用参数$L$来控制束搜索中优先队列的长度，并将基础数据的中心点（medoid）作为初始节点。

每一步中，束搜索从队列中选择距离查询最近的节点$v$，计算$v$的外邻居与查询之间的距离。

然后，如果某个节点距离查询更近，或队列尚未填满，该节点将被添加到队列中。当队列中无法再添加更近的节点时，搜索终止。

:one:使用$\text{beam search}$，控制队列长为$L$，以中心点作为起点