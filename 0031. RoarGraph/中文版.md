## RoarGraph：一种高效跨模态近似最近邻搜索的投影二分图

#### 摘要

近似最近邻搜索（ANNS）是许多应用程序中的基础和关键组件，包括推荐系统和基于大型语言模型的应用程序。随着多模态神经模型的发展，这些模型将来自不同模态的数据转换为共享的高维空间中的特征向量，跨模态ANNS的目标是使用来自一个模态（例如文本）的数据向量作为查询，从另一个模态（例如图像或视频）中检索最相似的项目。然而，不同模态的嵌入之间存在固有的分布差距，导致跨模态查询相对于基础数据成为分布外（OOD）数据。因此，最先进的ANNS方法在处理OOD工作负载时表现不佳。

------

在本文中，我们对OOD工作负载的特性进行了定量分析，以深入理解其ANNS效率。与单模态工作负载不同，我们揭示了OOD查询在空间上与基础数据存在偏差，并且OOD查询的k近邻在嵌入空间中彼此距离较远。这一特性破坏了现有ANNS方法的假设，并与它们为高效搜索而设计的结构不匹配。基于对OOD工作负载的洞察，我们提出了一种投影二分图（pRojected bipartite Graph, RoarGraph），这是一种在查询分布指导下构建的高效ANNS图索引。大量实验表明，RoarGraph在现代跨模态数据集上显著优于最先进的方法，对于OOD查询，在$90%$召回率下的搜索速度提高了最多$3.56 \times$倍。

## 1 引言

近似最近邻搜索（ANNS）是多个应用领域中基础且性能关键的组成部分，例如大规模信息检索 [49, 54, 78]、推荐系统 [11, 55] 和问答系统 [42, 62]。近年来，将检索增强生成（RAG）应用于大型语言模型（LLMs）的新兴应用同样利用向量数据库作为外部知识库，通过ANNS提升检索效率 [2, 46, 73]。这些应用需要对相似向量搜索提供快速且准确的响应，而ANNS可以高效地从数据库中为给定查询检索近似最近邻，从而避免执行不可行的精确k近邻搜索 [9, 19, 85]。为提升ANNS的性能，大量研究致力于设计高效的数据结构，包括基于分区的方法 [15, 65, 67, 81]、基于量化的方法 [4, 24, 26, 36, 77] 和基于哈希的方法 [13, 21, 31, 31, 86]，其中基于图的方法 $[20,52,56]$ 在许多数据集上表现出了最先进的性能。

------

近年来，随着多模态数据表示技术的发展，跨模态检索逐渐引起了广泛关注。诸如CLIP [59]等为多模态任务训练的深度学习模型，能够将来自不同模态（如视觉和自然语言）的非结构化数据嵌入到语义保持的共享高维空间中，即嵌入空间。在跨模态向量检索中，一个模态的数据（例如文本）被用作查询，以检索来自另一模态（例如图像或视频）中语义最相似的数据 [32, 41, 47]。鉴于跨模态检索在多样化和关键应用场景中的广泛需求，提升跨模态检索性能的高效ANNS显得尤为重要 [7, 63, 66, 68, 74, 80, 83]。然而，现有的ANNS索引主要针对单模态场景设计，在跨模态查询中表现不佳。例如，在现代跨模态数据集LAION [61]上，使用HNSW（分层可导航小世界）[52]索引进行文本-图像搜索时，为了使recall@10达到0.95，需要访问14374个节点；相比之下，如果使用图像搜索图像，仅需访问1568个节点，显示出近10倍的效率下降。

---

跨模态检索的主要特征在于来自两种模态的向量数据分布存在显著差异。尽管多模态神经嵌入模型可以实现不同模态向量之间的相似度度量，但在跨模态表示学习中，两种模态嵌入之间仍然存在一致且固有的分布差距，这被称为模态差距 [45]。因此，在跨模态ANNS中，查询向量相对于数据库中的向量（基础数据）属于分布外（OOD）[34]。这与单模态任务形成鲜明对比，在单模态工作负载中，查询向量与基础数据属于相同分布（ID）。马哈拉诺比斯距离 [51] 显示，在跨模态数据集（例如Text-to-Image [14]、LAION [61] 和 WebVid [5]）中，来自另一模态的查询向量比ID查询与基础数据之间的距离远 $10 \sim 100 \times$。此外，通过深入实验和分析，我们发现分布外查询距离基础数据较远，其$k$近邻彼此之间也相距较远。这表明查询不仅偏离了基础数据，而且OOD查询的最近邻（真实标签）比ID查询的最近邻分布得更为分散。

------

然而，当前最先进的ANNS索引主要是为ID查询设计的 $[20,52,56]$。这些方法假设查询出现在基础数据附近，并且查询的最近邻彼此靠近。在这一假设下，基于图的ANNS方法在索引构建阶段采用束搜索（n-贪婪搜索）来构建近似KNN图 [20, 35, 43, 50, 52]，其中距离较小的向量倾向于相互连接。此外，搜索阶段也使用束搜索，期望通过紧密连接的基础数据实现快速收敛。然而，这种索引设计在跨模态ANNS中面对OOD查询时表现不佳。由于跨模态查询和基础数据遵循不同的分布，并且OOD查询的真实标签分布较为分散，因此关于查询和基础数据分布的关键假设被破坏。结果是，这种基于图的跨模态搜索无法高效收敛，反而需要更多的图遍历跳跃操作。这正是现有ANNS方法在处理OOD工作负载时表现不佳的主要原因。

---

我们提出了一种名为**投影二分图（pRojected bipartite Graph, RoarGraph）**的高效图索引，基于查询分布知识，专门用于跨模态近似最近邻搜索（ANNS）。我们的核心思想是将查询的最近邻分布向量映射为图索引中紧密连接的邻居。RoarGraph的索引构建过程如下：首先，通过精细的边选择，基于查询与基础数据之间的相似关系构建一个二分图，并将其映射到统一的图结构中。其次，将二分图投影到基础数据上，结合邻域感知投影机制，为空间上较远但从查询视角看较近的节点创建连接路径。最后，执行连接增强方案，以确保图的连通性以及所有基础数据向量的可达性。RoarGraph索引仅由基础数据组成，但能有效保留查询分布推导出的邻接关系。本论文的主要贡献总结如下：

- 我们通过深入实验揭示了跨模态ANNS的低效性，并提出洞见性分析，阐明当前最先进方法在跨模态ANNS中性能下降的根本原因。
- 我们提出了一种新型的图索引——RoarGraph，用于高效跨模态ANNS，充分利用查询分布来指导图索引构建。
- 我们在三个跨模态数据集上（包括文本、图像和视频帧）进行了广泛实验，结果表明RoarGraph显著提高了跨模态向量搜索的性能。

------

RoarGraph通过减少搜索阶段的绕行路径和跳跃次数，加速跨模态向量搜索。这使其在现有图索引的基础上实现了显著性能提升，在三个跨模态数据集上搜索速度提高了$1.84 \times$到$3.56 \times$，召回率$@ \mathrm{k} \geq 0.9$，其中$\mathrm{k}=1, 10, 100$。特别是，RoarGraph还达到了现有方法无法实现的卓越召回率（recall@k $\geq 0.99$）。此外，我们方法的一个变体在NeurIPS 2023实用向量搜索（Big ANN）挑战赛的OOD赛道中获得了冠军。

## 2 背景与动机

本节介绍了近似最近邻搜索（ANNS）和分布外（OOD）ANNS的背景知识。同时，我们对现有ANNS方法在跨模态数据集上的性能进行了定量评估和分析。

### 2.1 ANNS 背景

**2.1.1 ANNS定义。**
 近似最近邻搜索（ANNS）起源于k近邻搜索（KNNS），其目标是从数据库（基础数据）中找到与给定查询向量最接近的$k$个向量。接近度的度量通常采用余弦距离、$\ell_{2}$距离、内积等方法。在现代应用中，处理的大规模数据集向量维度可能增加到数百维 [66]。由于“维度灾难”带来的挑战 [33]，精确的k近邻搜索（KNNS）变得昂贵且不切实际。为此，ANNS方法为基础数据创建特定索引，以在搜索速度和精度之间实现权衡。

---

**定义1.** 给定数据库中的N个向量$\mathcal{X}=\left\{x_{1}, \ldots, x_{N} \right\} \in\mathbb{R}^{D}, q \in \mathbb{R}^{D}$和一个用于计算两个向量之间距离的函数$\delta(\cdot, \cdot)$。Top-$k(k \leq N)$ ANNS的目标是找到
$$
\begin{equation*}
S=\mathrm{k}-\arg \min _{i \in 1, \ldots, N} \delta\left(q, x_{i}\right) \tag{1}
\end{equation*}
$$

集合$S$需满足：$|S|=k$，对于所有$x \in S$和$x^{\prime} \in \mathcal{X} \backslash S$，有$\delta(q, x) \leq(1+\epsilon) \delta\left(x^{\prime}, q\right)$，其中$\epsilon \geq 0$是一个小常数，仅用于描述ANNS满足的近似特性，而不是直接使用。

---

ANN索引的搜索性能将通过搜索速度与召回率的权衡来评估。召回率使用公式recall@$k=|S \cap K N N(q)| / k$计算，其中$K N N(q)$表示查询$q$的精确k近邻（真值），而$S$是结果集且满足$|S|=k$。

---

**2.1.2 最先进的ANNS方法。**

图基方法和倒排文件索引是两种常见的近似最近邻搜索（ANNS）方法。其中，图基方法是性能最优的ANNS方法家族，能够在搜索速度与召回率之间提供比其他方法更好的权衡 [20, 44, 50, 52, 56, 75]。这些方法将基础数据索引为图结构，其中每个节点表示一个数据向量。

**HNSW（Hierarchical Navigable Small World）[52]** 是一种广为人知的多层图结构。在构建过程中，所有基础向量首先插入到基础层（第0层）。随后，仅第$i$层的子集会以递减概率插入到第$i+1$层，层数越高，包含的节点越少（最顶层仅包含1个点）。每层中的节点会与其近似最近邻相连接。

在搜索阶段，HNSW针对给定查询首先在较高层进行贪婪搜索。来自较高层的最近点将作为下一层的入口点。在基础层，基于图执行束搜索。束搜索是贪婪搜索的一种变体，通过在有限队列中扩展最优候选元素来探索图 [57]，逐步收敛到查询的最近邻。队列的容量（称为束宽度）控制精度和搜索速度之间的权衡。

------

倒排文件索引（IVF）方法是ANNS中另一种常见的索引类型，因其在范围最近邻搜索中操作便利且性能优越而受到欢迎。例如，IVF [67] 和 IMI [3] 等方法。

IVF首先使用K-means算法对基础数据进行聚类，得到$n$个质心，然后将基础数据中的每个向量分配到其最近的聚类中。在搜索阶段，IVF选择与查询最接近的nprobe个质心，并扫描这些nprobe聚类中的所有向量，从而获取前$k$个结果。

### 2.2 分布外ANNS（OODANNS）

分布外近似最近邻搜索（OODANNS）指的是查询的分布与基础数据的分布不同。在现代跨模态应用中，两种模态的向量之间始终存在固有的分布差距 [45]。例如，当使用文本作为查询来检索相关的视觉数据时，会出现分布差距，导致查询成为分布外数据。不幸的是，大多数ANNS索引算法主要针对单模态任务设计，例如图像-图像搜索。

------

跨模态向量搜索的OOD特性可以通过两种数学距离来定量描述：衡量两种分布的Wasserstein距离 [38, 72] 和衡量向量到分布的Mahalanobis距离 [51]。我们使用这两个指标来评估三个现代真实世界多模态数据集上的数据分布：Text-to-Image [14]、LAION [61] 和 WebVid [5]。这些数据集的特性如表1所示。

------

为了用Wasserstein距离量化OOD特性，我们从基础数据中抽取两个互不相交的集合（$B_{1}, B_{2}$）以及一个来自查询向量的查询集合$(Q)$，每个集合包含100,000个向量。如表2所示，来自基础数据的两个样本在$W_{2}\left(B_{1}, B_{2}\right)$上表现出接近性。而查询分布相较于基础数据分布的偏离程度，在三个数据集上分别高出1.67倍、1.89倍和2.89倍。

------

除了整体分布差异外，如果查询的Mahalanobis距离与基础数据的距离显著不同于基础向量之间的距离 [34]，则认为该查询属于分布外数据。对于ID查询集中的每个$q_{id}$和查询集$Q$中的OOD查询$q_{ood}$，我们计算Mahalanobis距离来估计$d_{M}(q, P)$，其中$P$是基础数据分布。如图1所示，OOD查询显著偏离基础数据分布。特别是，来自LAION和WebVid的查询相较于Text-to-Image中的查询表现出更强的分布外特性。

### 2.3 当前方法在OOD-ANNS中的低效性

**2.3.1 当前方法在OOD工作负载上的性能表现。**
 我们在表1所示的三个多模态数据集上对IVF和HNSW进行了评估。分布内（ID）查询来自与基础数据具有相同经验分布的原始大规模数据集，而分布外（OOD）查询则使用每个数据集的文本查询集。IVF索引通过Faiss库 [37] 构建，HNSW索引使用官方实现 [52] 构建，并采用推荐参数进行实验。

------

如图2所示，OOD工作负载上存在显著的性能下降。当使用IVF索引时，与ID查询相比，OOD查询需要搜索显著更多的聚类才能达到较高的召回率。在三个数据集中，ID查询在搜索最接近的50个聚类时，Recall@10均超过0.97；然而，OOD查询的Recall@10分别仅为$0.91, 0.20$和0.52。

------

同样，在HNSW索引中，OOD查询在图上的束搜索过程中也需要访问显著更多的节点，导致在三个数据集上搜索效率较低。在LAION数据集中，OOD查询需要超过500次跳跃才能达到Recall@10 $\geq 0.93$，而ID查询仅需要48次跳跃。这突显了由于OOD查询导致的搜索路径长度增加了约10倍，从而带来了效率低下的问题。

实验结果表明，现有索引在跨模态ANNS任务中表现不佳，性能大幅下降，这进一步强调了设计高效索引的迫切需求。

---

**2.3.2 先前OOD-ANNS解决方案的局限性。**

针对OOD-ANNS问题设计的首个图索引是**RobustVamana**，其由OOD-DiskANN [34] 提出。RobustVamana的主要目标是利用查询向量在Vamana图 [35] 中添加边。在将基础数据连接后，还将查询插入到Vamana图中。随后，RobustVamana启动一个名为**RobustStitch**的互连过程，以在插入的查询关联的最近节点之间创建完整连接。

------

图3比较了RobustVamana与其原始设计Vamana在处理OOD工作负载时的性能表现。当召回率达到Recall@10=0.9时，RobustVamana相较于Vamana提供了$13% \sim 67%$的性能提升，但随着召回率的提高，这种提升变得越来越小。然而，在处理OOD查询时，RobustVamana平均比Vamana处理ID查询的速度分别慢了3.9倍、5.3倍和10.0倍（针对三个数据集）。

------

这些结果突显了现有OOD-ANNS解决方案在效率上的不足，并强调了设计一种新型索引以提升OOD工作负载性能的巨大潜力。

## 3 跨模态ANNS中OOD工作负载分析

本节对分布外（OOD）工作负载进行了分析，以深入理解现有方法在跨模态ANNS中难以实现高性能的原因。

### 3.1 基本差异

通过深入实验和分析，我们发现分布外ANNS（OODANNS）与分布内ANNS（ID-ANNS）之间存在两个关键差异。

---

**OOD查询距离其最近邻较远。** 在图4中，我们计算了查询与其最近邻$(\mathrm{k}=1)$之间的距离，表示为$\delta\left(q, i^{t h} N N\right)$。其中$q$表示查询，$\delta(\cdot, \cdot)$为数据集的距离度量函数。

从图中可以观察到，OOD查询与其最近邻之间的距离显著大于分布内查询与相同基础数据中真实标签之间的距离，即在ANNS背景下，$\delta\left(q_{o o d}, i^{t h} N N_{o o d}\right) \gg \delta\left(q_{i d}, i^{t h} N N_{i d}\right)$。

尽管存在极端值，但考虑中位数数据，OOD查询与最近邻之间的距离分别比ID查询远2.1倍、5.3倍和11.3倍。此外，我们还发现偏离的OOD查询会导致其$k$最近邻在高维空间中彼此距离较远，而ID查询的最近邻通常彼此靠近。

为验证OOD查询的$k$最近邻之间的空间分离程度，在$\mathrm{k}=100$的场景下，我们计算给定查询$q$的$i^{t h} N N(i=1 \ldots 100)$与其余99个最近邻之间的平均距离，共生成100个距离值来衡量查询$q$最近邻之间的分离程度。随后，通过所有查询的$i^{t h} N N$距离平均值反映这一特性。

图5展示了这一现象：OOD查询的最近邻之间的距离明显大于ID查询的最近邻，在三个数据集上分别高出1.29倍、1.45倍和2.11倍。这一发现表明，在OOD查询的前$k$个答案之间存在大量噪声数据向量。

---

为了说明这一反直觉的现象，我们在图6中展示了一个示例。基础数据用灰色点表示，围绕一个三维球面附近波动。一个分布内（ID）查询（绿色菱形）位于球面附近，并且被两个距离较近的最近邻（绿色点）所包围。而一个分布外（OOD）查询（红色方块）则远离球面表面，位于半球的某一区域内。两个蓝色点深陷于球体内部，彼此之间距离较远，但却成为OOD查询的最近邻。

------

图7展示了来自LAION数据集的真实示例。该图基于LAION数据集的500个数据点子集，通过K-means算法聚类成40个中心点生成。分别从ID查询和OOD查询中抽取三个示例，并计算每个查询的五个最近邻。然后使用主成分分析（PCA）[28]对10万个点进行降维处理，将数据降至二维进行可视化，并使用采样的500个向量计算Voronoi单元。

从结果中可以明显看出，ID查询的五个最近邻集中在相对靠近的Voronoi单元中。而OOD查询的五个最近邻在图中表现出显著的分散性，$5-\mathrm{NN}$落在彼此分离的Voronoi单元中。这进一步说明了OOD查询的最近邻在空间上具有较大分布间隔的特点。

### 3.2 Why Previous Methods Fail on OOD-ANNS

现有方法低效的主要原因在于，分布外（OOD）查询破坏了传统ANNS方法所依据的假设。当前最先进的ANNS索引背后的核心假设包括：

1. 查询与基础数据中的向量距离较近，假设查询与基础数据遵循相同的分布 [20,44,56]；
2. 查询的$k$个最近邻在空间$\mathbb{R}^{D}$中彼此靠近，或者某个邻居的邻居也很可能是查询的邻居 [16,20,44,56,57,64]。

------

基于这些假设，图基方法通常采用束搜索（beam search）来构建近似$k$最近邻图，并执行搜索操作 [19,20,43]。因此，这些方法将空间上相近的向量转换为图中紧密连接的节点，并进一步假设束搜索可以通过贪婪路由，在每一步逐步收缩搜索空间，高效地定位包含真实标签的搜索范围 [20,56,57]。

---

然而，对于OOD查询，搜索空间会显著扩大。考虑一个高维球体$B^{k}\left(1^{s t} N N, R\right)$，其中心为给定查询的第一个最近邻$1^{s t} N N$，半径$R$定义为该查询中所有最近邻之间的最大距离$\delta\left(i^{t h} N N, j^{t h} N N\right)$（其中$i \neq j$）。在图索引中，包围当前访问节点$x$的球体$B^{s}(x)$以及$B^{k}$构成可识别的搜索空间 [20,56]。

从图5可以观察到，$R_{\text {ood }}$远大于$R_{i d}$，其范围为$1.29 \times$到$2.11 \times$。假设球体体积表示为$C_{B} \times R^{D}$，其中$C_{B}$是固定维度$D$的常数，则高维空间中$R_{o o d}^{D} / R_{i d}^{D}$的比值会显著增加，这导致$B_{o o d}^{k}$的规模远大于$B_{i d}^{k}$。

与此同时，搜索空间$B^{s}(x)$会大幅扩张，并由于$B^{k}$的膨胀而难以高效缩小。对于OOD查询，其分散的最近邻会成为贪婪路由中的局部最优陷阱，导致搜索收敛困难。这表明，处理OOD查询需要访问大量节点。

------

为了进一步说明在搜索OOD查询时收敛的困难性，假设基于图7的数据构建了一个常用的图索引，其中距离较近的向量倾向于在图索引中相互连接。

对于ID查询，由于最近邻（蓝色六边形）彼此距离较近，沿着搜索路径$B^{s}(x)$可以轻松收缩。每次贪婪路由的推进都会将搜索空间收缩到包含ID查询最近邻的小球内 [20,56,57]。

然而，对于OOD查询，束搜索在单一方向上难以收敛。当路由到$k$个最近邻之一（红色菱形）时，即便搜索已到达某个近邻，搜索空间仍无法有效收缩。这是因为与ID查询相比，OOD查询的真实标签在一个更大的球体内分布。

为了获得较高的召回率，处理OOD查询的搜索过程需要更大的束宽、更长的搜索路径，以及在搜索过程中增加的计算和内存访问，以避开局部最优陷阱并找到分散的答案。这最终导致了性能下降。

---

基于空间划分的方法（例如IVF）在处理OOD查询时同样表现不佳。该类方法通过在基础数据上运行K-means算法获取聚类，其中距离较近的点被分配到同一聚类中。然而，对于OOD查询，其最近邻可能分布在分散且相距较远的聚类中。

对于OOD查询，包含最近质心的聚类可能并不包含真实标签，因为OOD查询识别出的近邻往往是分散的。在真实示例（图7）中，基于划分的方法表现出明显的性能影响：要达到召回率Recall@5=1.0，OOD查询需要扫描5个聚类，而ID查询仅需扫描2个聚类，导致性能下降约2.5倍。

对于百万规模的数据集，这种负面影响会进一步恶化，如第2.3.1节所述。

## 4 ROARGRAPH：一种高效处理OOD-ANNS的图索引

通过对OOD-ANNS低效性的揭示和深入分析，我们提出了**RoarGraph**——一种在查询分布指导下构建的图索引，用于在跨模态检索中提供高效的ANNS解决方案。

### 4.1 面向ANNS的查询引导索引：挑战

由于OOD工作负载的特殊特性破坏了现有ANNS方法设计中的假设，我们提出利用查询分布来指导图索引的构建。与基于较小距离连接基础节点的方法不同，我们的方法将从查询视角被认为相近的空间上相距较远的向量，转化为图索引中紧密连接的邻近节点。

基于这一目标，我们的方法利用查询来引导RoarGraph的构建。例如，我们使用来自原始十亿规模LAION数据集的图像标题嵌入向量，来构建支持LAION文本-图像搜索的RoarGraph。

---

为了有效利用查询分布来指导图结构的构建，**二分图**成为建模两种模态嵌入之间接近关系的合理选择。二分图在推荐系统中被广泛应用 [17, 27, 76]，其由两组节点组成，边仅连接不同组的节点，同组内的节点不相互连接。

------

在OOD-ANNS中，基础数据和查询可以被视为二分图中的两个不同节点集（基础节点和查询节点）。在这里，查询节点起到了关键作用，作为桥梁将基础数据中的最近邻与查询向量关联起来。此外，贪婪搜索可以在这样的二分图上执行：从一个基础节点出发，移动到其外邻居（查询节点），再访问这些查询节点的外邻居（基础节点），然后选择更近的基础节点继续搜索。

尽管这种结构自然适合建模两种分布的接近关系并支持搜索，但要构建一个高效的ANNS图索引仍然面临以下挑战：

------

**(1)** 在二分图中有效建立基础节点和查询节点之间的边，以建模两种模态之间的邻近关系，并在ANNS中实现实际的贪婪路由，这是一项复杂的任务。简单地将两类节点的最近邻连接起来，可能会导致节点度数过高，从而损害搜索效率。

---

**(2)** 在二分图上进行搜索需要经过查询节点的遍历，而保持查询节点较高的出度（例如$\geq 100$）对于覆盖基础数据至关重要。然而，这会在每次跳跃时带来较高的开销，并增加沿路由路径访问的节点数量，从而降低搜索速度。

由于每次访问基础节点都涉及从主存储器加载向量数据到CPU，并计算其与查询的距离，这两个过程在节点访问操作中非常耗时 [10]。访问的节点越多，内存访问和计算负担就越重。因此，在保持可导航搜索路径的同时，需要进一步降低节点的度数。此外，二分图由于包含两种节点类型和边，导致内存消耗进一步增加。

------

**(3)** 当利用查询引导图结构构建时，会出现基础节点可达性和连通性方面的局限性。仅依赖二分图中查询节点的外邻居来覆盖整个基础数据变得具有挑战性，这可能导致孤立节点或组件的出现，从而影响搜索效率。

### 4.2 设计与实现

**4.2.1 概述。**
 RoarGraph旨在解决上述挑战，并在跨模态ANNS中提供卓越的性能。RoarGraph的构建过程可分为三个步骤，如图8(c-e)所示。

------

在初始步骤中，我们利用**查询-基础二分图**（图8(c)）将查询（查询节点）和基础数据（基础节点）统一到同一数据结构中。在构建二分图之前，会在预处理阶段计算查询向量的真实标签（图8(a)）。

随后，我们为每个查询建立与其$N_{q}$个最近邻的边，并在限制条件下从基础节点向查询添加边，即仅允许其内邻居中最接近的基础节点链接到查询节点（图8(c)中的蓝色箭头）。这种方法实现了两个主要目标：

1. 在查询与基础数据之间创建接近关系的映射；
2. 降低基础节点的出度，从而提高二分图上的搜索效率，解决挑战1。

------

其次，我们提出了一种名为**邻域感知投影**（Neighborhood-Aware Projection）的技术，以将二分图有效地投影到基础数据上。在投影之前，为每个节点施加度数限制。对于每个查询节点，我们选择一个已连接的基础节点作为中心点（pivot），从对应查询节点的外邻居中选择邻居。

选择最接近中心点的节点后，按距离逐步选择更远的节点。通过**邻域感知投影**，我们移除了查询节点，但在投影图中保留了从查询分布中获得的邻近关系（图8(d)）。

这种方式降低了图的平均度数，使得投影图变得可导航 [20,52]。因此，在搜索过程中减少了需要访问的节点数量，从而解决挑战2。

------

在最后一步中，我们对投影图应用**连接性增强**（Connectivity Enhancement）技术，以解决孤立节点、分离图组件以及节点之间可选路径不足等问题（解决挑战3）。

具体而言，我们使用束搜索遍历投影图中的每个节点，并在额外的度数预算下将邻近节点作为补充邻居加入到每个节点中。

这一过程提高了图的连通性和可达性，从而完成RoarGraph索引的构建（图8(e)）。

随后，我们将详细介绍设计原理以及每项技术优化的具体内容。

---

**4.2.2 查询-基础二分图。**

我们构建了查询-基础二分图，该图作为统一的容器，用于在基础数据和查询的分布之间建立邻近关系映射。在二分图中，查询$(\mathcal{T})$和基础数据$(\mathcal{X})$分别作为两种不同类型的节点：查询节点和基础节点。需要建立两种有向边：

1. 从基础节点到查询节点的边；
2. 从查询节点到基础节点的边。

------

首先，为了构建能够从查询视角识别基础数据邻近关系的二分图，我们从查询节点到基础节点建立边。具体而言，从每个查询节点向其在基础数据中的$N_{q}$个最近邻（基础节点）添加有向边。

维持查询节点较高的出度（图8(b)中$N_{q}=3$）是至关重要的，主要原因包括：

1. 扩大基础数据的覆盖范围，并通过查询充分建模基础数据中的邻近关系；
2. 确保查询的外邻居具有重叠性，使得在搜索过程中二分图内的大多数基础节点可达。

------

其次，为了将基础节点连接到查询节点，我们尝试了一种简单策略：将现有的有向边转换为双向边，从而为基础节点分配度数$d=N_{q}$。然而，这种方法需要在二分图搜索的每一步检查邻居的邻居（$N_{q}^{2}$个节点），如4.1节所述，效率较低。

因此，我们提出了一种更实用的策略：为每个查询节点保留$N_{q}$个指向最近邻的链接（见算法1，第3行），并降低$d$以优化效率。

与我们的设计目标一致，即最小化$d$并建模邻近关系，我们选择每个查询节点的$N_{q}$个外邻居中最近的基础节点$x$，并从$x$向其对应的查询节点添加一条边。这一策略将$d$降低到1，并完成二分图的构建。同时，我们移除查询节点到$x$的链接，即算法1中第4-6行的$t_{c} \rightarrow x$。

------

图8(b-c)展示了查询-基础二分图的构建过程。在示例中，当$N_{q}=3$时，二分图中每个查询节点有两个外邻居，而其他基础节点的出度为1。

在图8(c)中，节点C作为算法1中查询节点$Q_{1}$的$x$。节点G由于度数限制和与查询节点的接近性不足而被隔离，这种现象在真实数据集 [5, 14, 61] 中经常出现。

---

**4.2.3 邻域感知投影（Neighborhood-Aware Projection）。**

尽管查询-基础二分图在内存消耗方面较高，我们发现在该二分图上进行搜索效率较低。这是因为通过查询节点的路由需要较长的搜索路径，并且沿搜索路径访问的节点过多（每跳大约访问$N_{q}$个基础节点）。

为了解决这一问题，我们提出将二分图投影到基础节点上。虽然一种直接的二分图投影方法可以完全连接共享共同邻居的节点 [87]，但由于无法满足降低节点度数的目标，该方法不适合用作图索引。因此，我们提出了一种**邻域感知投影**方法，以在删除查询节点的同时保留查询节点识别出的基础节点邻域关系。

在图8(d)中，图被投影后，查询节点的外邻居与中心节点（pivot）$\mathrm{C}, \mathrm{D}$和$\mathrm{E}$相连。由于度数限制，边$D \rightarrow B$和$F \rightarrow D$未被建立。

------

我们在图9中说明了投影过程。查询节点作为桥接节点（绿色节点），其输入邻居被指定为**中心点（pivot）**（节点P），负责在投影过程中选择其邻居。当前投影中过滤掉了大量靠近但无关的灰色节点。

对于每个中心点，其桥接节点的外邻居成为中心点的潜在邻居（注意：基础节点的邻居的邻居也是基础节点）。这些潜在候选节点表示查询的最近邻，但彼此之间距离较远（如第3节所示）。这些候选节点被放入一个容量为$L$的候选队列中，并按到中心点的距离进行排序（算法2，第5-6行）。

------

接下来，从队列中选择最接近的节点作为中心点的外邻居（算法3，第2行；图9(b)），然后从候选队列中为每个中心点选择最多$M$个邻居以满足度数限制。

邻居选择的核心思想是：如果候选节点到现有邻居的距离小于到中心点的距离，则该候选节点将被排除在中心点的外邻居列表之外（算法3，第4行）。

这种策略包含了查询视角下较近但在空间上分散的候选节点，以便为基础节点建立有效路径。例如，在图9(c)中，我们观察到节点$Y$更容易通过节点$X$到达，而节点$Z$更难找到，因为$Y$相对更接近$X$，而$X$已连接到中心点P。因此，节点$X$和$Z$成为P的邻居，且符合度数限制。

------

为了最大限度地利用查询分布的信息，我们会在投影过程中，在$M$度数限制内尽可能填充外邻居（算法3，第8行）。例如，尽管节点$Y$之前被过滤掉，但在度数限制$=3$的填充操作中包含它，可以确保不会浪费度数预算。

在为每个中心点获取邻居后，我们还检查是否可以为其输入邻居建立反向链接（算法2，第9行）。

---

**4.2.4 连通性增强（Connectivity Enhancement）。**

投影图虽然保留了查询分布的信息，但仅依赖于二分图的覆盖范围无法充分提供合适的可达性和连通性，这对贪婪路由至关重要 [20,57]。

如图8(d)所示，节点G被隔离，节点B不可达，而路径$A \rightarrow D$过长。这一问题在真实数据集实例中进一步得到了验证（见图10(a)），其中$7%$的节点被隔离，$20%$的节点度数小于或等于1。这意味着搜索过程无法访问这些节点，即使它们是查询的真实标签。此外，连通性薄弱可能导致搜索路径过长。

------

为了克服这一限制并增强可导航性，我们对投影图$G^{\prime}$应用**连通性增强**（算法1，第10行），然后在最终步骤中合并$G^{\prime}$与$G_{pj}$中的边。

具体而言，从基础数据的**中心点（medoid）**开始，我们将基础向量视为查询，并针对每个节点执行束搜索（beam search），队列容量设为$L$。收敛后，它返回访问的$L$个节点作为结果。

每个基础节点通过算法3从其结果中获取补充邻居，同时尝试添加反向边（算法1，第12-14行）。

重要的是，这些补充邻居有助于远距离节点之间的OOD查询路由，因为这些边是基于投影图中的路径构建的。

------

如图8(c)所示，蓝色边将节点G包含到图中，使节点B变得可达，并缩短了节点之间的路径。例如，路径$\mathrm{A} \rightarrow \mathrm{D}$从4跳减少到3跳，路径$\mathrm{B} \rightarrow \mathrm{A}$从4跳减少到2跳。

图10(b)展示了连通性增强的效果，它增强了贪婪搜索的可导航性，使节点变得可达，并通过连接边减少了迂回路径 [20, 52]。

请注意，该图中忽略了边的方向，并且节点的布局并未准确反映实际几何关系，而仅用于展示图结构。

### 4.3 RoarGraph上的搜索

贪婪路由是基于图的ANNS的常规搜索方法。作为一种通用图索引，RoarGraph同样采用**束搜索**（beam search）作为搜索算法。需要强调的是，现有的ANN索引优化和压缩技术 [1,9,22,36,36] 与RoarGraph是**正交的**，因此RoarGraph可以直接采用这些优化技术来进一步提升性能（如果需要）。

------

在搜索过程中，我们使用参数$L$来控制束搜索中优先队列的长度，并将基础数据的中心点（medoid）作为初始节点。

每一步中，束搜索从队列中选择距离查询最近的节点$v$，计算$v$的外邻居与查询之间的距离。

然后，如果某个节点距离查询更近，或队列尚未填满，该节点将被添加到队列中。当队列中无法再添加更近的节点时，搜索终止。

## 5 实验

本节介绍实验设置，评估RoarGraph与最先进的图索引方法的性能对比，并进行消融实验分析。

### 5.1 实验设置

**数据集。** 实验使用了表1中列出的三个现代大规模跨模态数据集进行评估：

1. **Text-to-Image [14]** - 这是一个流行的基准数据集，其中查询分布与基础数据不同，包括由Se-ResNext-101模型 [29]（DSSM模型 [30] 的变体）生成的图像和文本查询向量。相似度评估基于内积计算，称为MIPS（最大内积搜索），内积值越大表示关系越紧密。
2. **LAION [58]** - 包含数百万对图像-替代文本（Image-Alt-Text）对，作为向量搜索基准数据集 [70] 使用。图像和文本的嵌入向量由高级模型CLIP-ViT$B/32$ [59]生成，相似度测量采用余弦距离。
3. **WebVid [5]** - 包含从素材网站获取的字幕和视频对，其相似度基于余弦距离计算。本文使用的WebVid嵌入向量是由CLIP-ViT-B/32编码的帧嵌入 [39]。

在实验中，Text-to-Image使用[14]的官方1万条向量作为查询集，而LAION和WebVid则分别从原始数据集中采样1万条文本向量进行评估。此外，每个数据集中还提供了大量与查询集不重叠的文本向量，用于索引构建。

---

**算法和参数设置。**

在评估中选择基于图的方法作为基线算法，因为它们表现出色 [44]。HNSW [52]和NSG [20]因其搜索效率广受认可。最近的$\tau$-MNG [56]通过在接近节点之间建立额外的连接，在ID-ANNS中实现了最先进的Recall@100性能。此外，RobustVamana [34]（第3节介绍）是唯一专门为OOD查询设计的索引。

我们根据官方说明和经验实验，为所有算法设置了最佳参数：

- **HNSW [52]**：将$M$从8调整到48，最终设置$M=32$来控制节点的出度，efConstruction设为500。
- **NSG [56]**：将度数限制$R=64$，设置$C=L=500$以提供高质量的邻居。
- **$\tau$-MNG [56]**：$\tau$-MNG与NSG共享内部参数$R, C, L$，分别设置为64, 500, 500。根据其论文建议，将参数$\tau$从0.01调整到0.3，并最终在所有数据集上将$\tau$设置为0.01以获得最佳性能。
- **RobustVamana [34]**：将$R=64, L=500$，并将$\alpha$从1.0调整到1.2，最终设置为$\alpha=1.0$。查询数量与基础数据规模一致，用于索引构建以获得最佳性能。
- **RoarGraph（本文提出）**：设置$N_{q}=100$控制二分图连接，$M=35$和$L=500$用于邻域感知投影和连通性增强。与RobustVamana类似，使用与基础数据规模相同的查询数量构建索引。

所有算法均使用官方代码构建索引并执行搜索。RoarGraph采用C++实现，所有源代码均使用GCC 10.5.0编译，并启用-O3优化。

---

**性能指标。**

参考以往研究 [19, 20, 50, 52, 75]，我们使用**recall@k**（定义见第2.1.1节）来衡量检索的准确性，并在评估中报告所有查询的平均recall@k。

此外，我们采用每秒查询数（QPS），这在单线程场景中等同于**延迟**，用于衡量搜索速度 [19, 20, 22, 52, 56, 75]。

为了全面验证各方法在不同检索场景下的有效性，我们在评估过程中将$k$的取值设置为1、10和100。

------

实验在一台配备双$\operatorname{Intel}(\mathrm{R})$ Xeon(R) Gold 5318Y CPU和512 GB内存的机器上进行，操作系统为Ubuntu 20.04。

为确保公平比较，所有算法均在**单线程模式**下运行，因为部分方法的官方实现不支持多线程。

### 5.2 搜索速度与召回率

图11报告了QPS与召回率的结果。传统的图基方法（如HNSW、NSG和$\tau$-MNG）是针对ID搜索设计的，在跨模态ANNS中的OOD工作负载表现较差。

作为专门针对OOD任务的解决方案，RobustVamana在LAION和WebVid数据集上针对recall@1和recall@10的性能优于三种ID索引方法。然而，本文提出的RoarGraph在所有召回率范围内（当$k$在recall$@k$中变化为1到100时），在三个跨模态数据集上始终优于所有最先进的图索引方法。

具体而言，当recall@10 $\geq 0.9$时，RoarGraph在Text-to-Image、LAION和WebVid数据集上分别比最有效的图索引加速了$1.84 \times, 2.58 \times$和$3.56 \times$。在$k=1$和$k=100$的情况下也观察到类似的性能提升。此外，RoarGraph在LAION和WebVid数据集上能够达到recall@100 $\geq 0.99$甚至更高的水平，这是其他任何图索引算法都难以实际实现的。

------

这一观察结果验证了第3节中的分析和动机。在三个传统图算法中，HNSW和NSG表现相似，而最新的索引$\tau$-MNG [56]在跨模态数据集上的性能较低，尤其是在$k=1$和10时表现更差。

这主要是因为$\tau$-MNG基于NSG添加了更多边来连接节点周围的近邻。然而，根据我们的分析，OOD查询的最近邻并不像ID查询那样聚集分布。真实标签往往分布较广，因此$\tau$-MNG通过连接较近节点提高连通性的策略对搜索效率贡献不大，反而增加了计算负担。

### 5.3 路由跳数与召回率

在基于图的索引中，实现目标召回率所需的跳数是搜索效率的另一项衡量指标。搜索过程中，每次跳跃都会产生一定的计算成本，用于检查图中邻居节点。跳数越少通常表示搜索路径越短，从而提高搜索效率 [35, 44]。

在图12中，我们评估了束搜索过程中三种典型图索引（HNSW、RobustVamana和RoarGraph）的跳数情况。

结果显示，与HNSW和RobustVamana相比，RoarGraph在三个数据集上的搜索跳数显著减少。例如，当recall@10 $\geq 0.90$时，RoarGraph的跳数分别降至以下比例：

- 相较于HNSW：减少$44.1%, 21.0%$和$10.9%$；
- 相较于RobustVamana：减少$53.1%, 54.7%$和$41.1%$。

随着召回率@k的增加，这些比例逐渐降低，进一步强调了RoarGraph在跨模态查询中建立了有效的边连接，从而优化了导航路径和搜索效率。

### 5.4 消融实验

我们进行了对比评估，以验证RoarGraph构建过程中各项技术的有效性。参与实验的包括在RoarGraph生成之前创建的**查询-基础二分图**和**投影图**，分别表示为$G_{bi}$和$G_{pj}$，它们均可用于查询。

评估时采用**QPS-召回率**指标，而不是**跳数-召回率**。这是因为，与具有类似度数限制的HNSW和RoarGraph比较不同，二分图必须保持查询节点的较高出度，这导致每跳访问的节点数量远多于$G_{pj}$和RoarGraph。因此，在比较$G_{bi}, G_{pj}$和RoarGraph时，跳数的减少无法匹配QPS提升所反映的改进。

例如，在LAION数据集上：

- 查询跳数$\geq 100$时，访问的节点数分别为10507、2426和3494；
- recall@10分别为0.918、0.906和0.937，对应查询-基础二分图、投影图和RoarGraph。

这些统计结果表明，$G_{bi}$需要每跳访问更多的节点。此外，这也验证了投影图得益于**邻域感知投影**（Neighborhood-Aware Projection）技术，有效降低了节点度数，并在处理OOD查询时表现出贪婪路由导航能力。投影图仅访问2426个节点，即可在约100跳内实现recall@10=0.9。

**连通性增强（Connectivity Enhancement）**通过增加补充边提升了节点的度数，提高了图的可达性和连通性。我们认为它引入了更多可选路径，有助于缩短搜索路径，并在高召回率条件下增强搜索精度。

------

图13中的性能评估结果表明，二分图在三个数据集上的表现最差，这与分析一致。而**投影图**通过**邻域感知投影**在所有召回率范围内实现了数倍加速。

我们观察到RoarGraph在Text-to-Image数据集上比投影图快$1.49 \times$，但在LAION和WebVid数据集上，当recall@10 $\leq 0.86$时，投影图表现出更高的效率。

这一现象归因于**连通性增强**增加了节点度数。在低召回率条件下，这些补充边引入了额外的计算开销，但在高召回率条件下，它们在寻找有效路径和收敛方面发挥了重要作用。

### 5.5 查询集规模对索引的影响

为了评估RoarGraph对索引构建中查询数量 ($|\mathcal{T}|$) 的敏感性，我们通过调整系数$p$使$|\mathcal{T}|=p \times|\mathcal{X}|$，并将查询集表示为$\mathcal{T}_{p}$，测试QPS与召回率之间的权衡。

------

图14展示了在索引构建过程中，不同查询集规模与召回率之间的关系。评估设置$p$为基础数据规模的$10%$、$50%$和$100%$。

结果显示，在RoarGraph构建过程中使用$\mathcal{T}*{0.5}$可以在所有数据集上获得与使用$\mathcal{T}*{1}$相当的性能表现（recall@10和recall@100）。

尽管查询集规模减少会导致性能下降，但使用$\mathcal{T}*{0.1}$构建的索引在实现recall@$100 \geq 0.95$时仅比$\mathcal{T}*{0.5}$构建的索引慢$11.3%, 12.9%$和$29.2%$。

更重要的是，实验结果表明，即使仅使用$\mathcal{T}_{0.1}$构建RoarGraph，依然保持卓越的效率，在达到recall@10 $=0.9$时，相比HNSW提高了$1.44-4.38 \times$的性能。

------

### 5.6 面向分布内查询的鲁棒性

除了在OOD-ANNS中表现优异之外，一个ANNS索引还需要有效处理分布内（ID）查询，以便在应用中同时支持不同类型的查询。因此，我们在实验中使用ID查询作为工作负载，对单模态ANNS进行对比分析。

对于三个数据集，每个ID查询包含从原始大规模数据集中抽样的1万条视觉嵌入向量。

------

如图15所示，RoarGraph在ID工作负载下表现出较强的鲁棒性，并在三个数据集上展现出与HNSW相当的效率。

尽管RobustVamana整体上比RoarGraph和HNSW速度更慢，但在LAION数据集上达到了recall@10 $\geq 0.995$，而HNSW和RoarGraph均未能达到这一水平。

### 5.7 索引大小与构建开销

图16比较了索引大小和索引构建的开销。最终的索引大小反映了搜索阶段的内存消耗。

如图所示，RoarGraph的索引大小在Text-to-Image、LAION和WebVid数据集上分别消耗了9.04 GB、20.64 GB和5.07 GB——仅略大于NSG。这表明RoarGraph在保持较小内存开销的同时，显著提升了跨模态ANNS的性能。

------

在索引构建开销评估中，我们为所有图索引算法使用了64个线程。

我们对比了RoarGraph在两种查询向量集规模下的构建时间：$100 %$ 和 $10 %\left(\mathcal{T}*{1}\right.$ 和 $\left.\mathcal{T}*{0.1}\right)$，分别相对于基础数据量。

- HNSW在所有数据集中表现为构建时间最短的索引。
- NSG和$\tau$-MNG需要构建近似最近邻图，这增加了构建时间。

具体来说：

- 在使用$\mathcal{T}_{1}$构建RoarGraph时，构建时间比RobustVamana长1.12到3.02倍，比NSG长1.7到7.5倍，比HNSW长4.8到17.5倍。然而，在WebVid上，RoarGraph比$\tau$-MNG快$21%$。
- RoarGraph的预处理阶段（计算查询向量的真实标签）占总构建时间的$87 %$到$93 %$（基于$\mathcal{T}_{1}$）。

------

使用$\mathcal{T}_{0.1}$构建时，RoarGraph的构建时间大幅减少：

- 仅需$\tau$-MNG构建时间的$16 %$到$54 %$；
- 仅需NSG构建时间的$35 %$到$98 %$；
- 在Text-to-Image和LAION数据集上，构建时间仍然是HNSW的两倍，但在WebVid数据集上，与HNSW的构建时间相当。

在这种情况下，预处理阶段占总构建时间的比例分别为：

- Text-to-Image：$67%$；
- LAION：$73%$；
- WebVid：$43%$。

------

综上所述，使用$\mathcal{T}_{0.1}$构建的RoarGraph仍然提供了显著的搜索性能提升（参见第5.5节），同时大幅减少了构建时间。这使得应用程序可以在**构建成本**和**搜索效率**之间进行权衡，使其成为一个灵活且实用的选择，适用于不同场景。

## 6 讨论

**RoarGraph 在实际场景中的构建。**

RoarGraph 的核心理念是有效利用跨模态查询向量来构建图索引，从而显著提升跨模态向量搜索性能，并可应用于以下实际场景：

------

大型基于嵌入的检索和推荐系统（如 Bing [71]、YouTube [12]、Amazon [8, 40, 82]、TikTok [23, 48]、Pinterest [27] 等）通常拥有大量的历史查询数据。因此，作为一种工作负载驱动的跨模态ANNS索引，RoarGraph可以充分利用这些历史查询向量来构建索引。此外，此类应用还可以利用其多模态深度学习模型（为基础数据和查询生成嵌入）对大规模（多达十亿级）的公共真实数据集 [5,53,60,61] 进行编码，以便在需要时补充数据。

在查询数量有限的情况下，RoarGraph 仍然能够显著提升性能（详见第5.5节）。

------

**RoarGraph 的更新机制。**

在索引构建过程中，查询-基础二分图会被保存下来，以便支持RoarGraph的离线插入功能。

插入过程如下：

1. 将新的基础数据向量$v$视为查询，通过RoarGraph搜索其近似最近邻。
2. 仅返回由至少一个查询节点$q$连接的基础节点作为结果。
3. 如果多个查询节点符合条件，则选择距离$v$最近的$q$。

接下来，利用$q$的外邻居$N_{\text {out}}(q)$，将$v$和$q$整合为子二分图$\left(N_{\text {out}}(q) \cup q \cup v\right)$。随后，对该子二分图应用**邻域感知投影（Neighborhood-Aware Projection）**，以$v$作为中心点生成投影图，并将新向量$v$相关的边合并到RoarGraph中完成插入操作。此外，二分图会更新$v$，将其加入$q$的外邻居，为后续插入铺平道路。

该插入策略避免了在二分图中计算新数据与查询节点之间精确距离的高成本。使用64线程时，在LAION数据集中插入200万个基础数据向量仅耗时583秒，这仅占重建索引时间的7%。

------

我们在不同插入数量下对索引进行了评估，并与重建索引进行了对比。插入的数据量按数据集规模的1-20%进行调整。

图17显示，通过此插入策略更新的RoarGraph索引在性能上与重建索引具有竞争力。例如：

- 在Text-to-Image和LAION数据集上，处理200万个向量插入后，当recall@10=0.95时，RoarGraph相较重建索引分别下降约13%和10%的性能。
- 在WebVid-2.5M中，插入50万个向量后，recall@10=0.95的QPS下降约17%。

------

**关于删除操作。**

RoarGraph 使用墓碑标记法（tombstones）标记删除点 [56, 79]。被删除的点仍参与路由，但不会出现在搜索结果中。

------

**当前更新机制的挑战：**

1. 在处理连续大规模插入时，后续构建的二分图对近邻关系的近似程度可能低于重建的索引。
2. 墓碑标记法需要随着更新的累积进行周期性重建 [56]。

上述挑战表明，插入和删除方法仍需在未来工作中进一步探索和优化。

## 7 相关工作

关于近似最近邻搜索（ANNS）的研究文献非常丰富。除了前文介绍的方法之外，还有一些研究利用查询来提升基于图的ANNS性能。

在文献 [43] 中，束搜索的终止条件被定义为二元分类任务，并利用查询训练分类模型来判断何时终止搜索。

文献 [6] 将图卷积网络（GCN）引入ANNS，通过从大量训练查询中学习来发现最优的搜索路由路径。此外，文献 [18] 将强化学习与GCN相结合，以引导基于邻近图的搜索路由。

另一项研究GraSP [84] 采用概率模型和子图采样，从查询分布中学习边的重要性得分，并在图索引中修剪边。然而，这些基于学习的方法在索引构建阶段需要昂贵的训练和调整过程。

------

在推荐系统中，文献 [69] 利用神经网络进行相似度排序，并通过二分图连接用户和物品，在二分图上执行搜索。该研究指出，在物品向量或用户向量之间没有定义相似度度量，因此边只能建立在两类节点之间。这种情况与跨模态检索不同，因为跨模态检索可以评估不同基础向量或查询向量之间的相似度。

------

ScaNN [26] 结合向量量化（VQ）[25]和乘积量化（PQ）[36]，使用各向异性损失进行分区和压缩。同时应用优化技术，例如标量量化、重新评分以及SIMD寄存器内PQ查找 [1]，以实现快速搜索。

------

关于基于图的ANNS方法，还有几项理论分析研究 [19, 20, 56, 57, 64]。这些研究推导了图索引搜索过程的时间复杂度，并假设查询与基础数据遵循相同分布。然而，当应用于跨模态ANNS时，这些理论分析面临较大挑战。

------

## 8 结论

跨模态数据检索是重要的工作负载之一。本文对OOD查询进行了深入分析。我们发现，在高维嵌入空间中，OOD查询的k-最近邻之间彼此距离较远。这是现有ANNS方法效率低下的根本原因，因为该特性破坏了现有设计中的假设条件。

为此，我们提出了**RoarGraph**——一种高效处理OOD-ANNS的图索引，该索引基于查询分布指导构建。

大量实验结果表明，RoarGraph在跨模态向量搜索中表现出卓越的性能。

