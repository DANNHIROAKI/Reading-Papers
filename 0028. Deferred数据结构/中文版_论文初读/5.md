# 5. Domination problems.

在本节中，我们研究了一个与 $k$ 维空间中的点支配问题相关的问题。这个问题并不直接适用于 $\S 2$ 末尾提出的范式。然而，通过高维的类似分治方法，我们能够将我们的技术适应于这种问题。

---

设 $p_i$ 表示点 $p$ 在 $k$ 维空间中的第 $i$ 坐标。我们说点 $p$ 支配点 $q$，当且仅当对于所有的 $i$，$1 \leq i \leq k$，都有 $p_i \geq q_i$。Bentley [2] 考虑了支配计数问题，这也叫做 ECDF 搜索问题。在这个问题中，我们给定了一个 $k$ 维空间中的点集 $P = {p_1, p_2, \dots, p_n}$，对于每个查询点 $q$，我们需要报告被 $q$ 支配的点的数量。

---

Bentley 使用多维分治策略来解决这个问题。他构建了一种数据结构，称为 ECDF 树，在经过一个预处理阶段后，这个树可以在 $O(\log^k n)$ 时间内回答每个查询，而预处理阶段的时间复杂度为 $O(n \log^{k-1} n)$。这个结果适用于固定维度数（$k$）并且 $n$ 为 2 的幂的情况。然而，Monier [9] 的更详细分析表明，这个结果对于任意的 $n$ 和 $k$ 都是有效的。事实上，Monier 表明，$O$ 结果中的常数为 $1 / (k-1)!$。在以下分析中，我们也假设维度数是固定的，且 $n$ 是 2 的幂。我们的结果可以通过引入 Monier 的结果，推广到任意的 $k$ 和 $n$。

---

多维分治的基本范式如下：给定一个涉及 $n$ 个点的 $k$ 维空间问题，首先将其划分为两个子问题，每个子问题包含 $n / 2$ 个点在 $k$ 维空间中，然后递归地在 $(k-1)$ 维空间中解决一个最多包含 $n$ 个点的问题。当应用于支配计数问题时，这个范式会产生以下的搜索或计数策略：

1. 找到一个 $(k-1)$ 维超平面 $M$，将点集 $P$ 划分为两个子集 $P_1$ 和 $P_2$，每个子集包含 $n / 2$ 个点。我们假设 $M$ 的形式为 $x_k=c$，因此，$P_1$ 中的所有点的第 $k$ 坐标都小于 $c$，而 $P_2$ 中的所有点的第 $k$ 坐标都大于 $c$。
2. 如果查询点 $q$ 位于与 $P_1$ 相同的一侧（即 $q_k < c$），那么只需要在 $P_1$ 中递归搜索。显然，查询点 $q$ 不能支配 $P_2$ 中的任何点。
3. 否则，$q$ 位于与 $P_2$ 相同的一侧（即 $q_k > c$），我们知道 $q$ 在第 $k$ 坐标上支配了 $P_1$ 中的所有点。此时，我们将 $P_1$ 和 $q$ 投影到超平面 $M$ 上，并递归地在 $(k-1)$ 维空间中搜索。同时，我们还在 $P_2$ 中继续进行 $k$ 维空间的搜索。

在图 5 中，我们展示了这个策略在二维空间中的应用。

---

在一维空间中，ECDF 搜索问题简化为在给定数据集中找到查询值的秩。 一维 ECDF 搜索树是对 $P$ 中 $n$ 个点的最优二叉搜索树。 $k$ 维 ECDF 树是一个递归构建的数据结构。该树的根包含 $M$，即第 $k$ 维的中位超平面。左子树是 $P_1$ 中的 $n / 2$ 个点的 $k$ 维 ECDF 树，其中 $P_1$ 是位于 $M$ 以下的点。类似地，右子树是 $P_2$ 中的 $n / 2$ 个点的 $k$ 维 ECDF 树，其中 $P_2$ 是位于 $M$ 以上的点。根节点还包含一个 $(k-1)$ 维的 ECDF 树，表示投影到超平面 $M$ 上的 $P_1$ 中的点。

---

为了回答查询 $q$，搜索算法将查询点的第 $k$ 坐标 $q_k$ 与中位平面 $M$ 上的定义值 $c$ 进行比较。如果 $q_k$ 小于 $c$，则搜索仅限于 $P_1$ 中的点。此时，算法会递归地在左子树中进行搜索。另一方面，如果 $q_k$ 大于 $c$，则算法会递归地在右子树中进行搜索，并且还会在根节点存储的 $(k-1)$ 维 ECDF 树中进行搜索。对于一维 ECDF 树，算法就是标准的二叉树搜索。对于固定的 $k$，构建 $k$ 维 ECDF 树的预处理时间为 $p(n) = O\left(n \log^k n\right)$，而回答单个查询所需的时间为 $q(n) = O\left(\log^k n\right)$。

---

我们现在将延迟数据结构技术应用于 $k$ 维 ECDF 树。与之前一样，我们不执行任何预处理来构建搜索树。ECDF 树是在回答查询的过程中按需构建的。最初，所有点都存储在 $k$ 维 ECDF 树的根节点。一般来说，当查询搜索到一个未展开的节点 $v$ 时，我们计算中位超平面 $M_v$，并根据 $\boldsymbol{M}_v$ 将数据点进行分区。然后，将这两个集合传递到 $v$ 的两个子节点。同时，我们初始化一个 $(k-1)$ 维的 ECDF 树，该树将在节点 $v$ 处创建。即使是这些低维树也将在回答查询的过程中按需创建。将延迟数据结构应用于 ECDF 树得出了以下定理。

---

**定理 11**：在 $k$ 维空间中回答 $r$ 个支配查询的代价为 $O(F(n, r, k))$，其中

$F(n, r, k)= \begin{cases}n \log ^k r+r \log ^k n, & r \leqq n, \\ n \log ^k n+r \log ^k n, & r>n .\end{cases}$ 

**证明**：该证明将通过对 $k$ 和 $n$ 进行归纳来完成。我们很容易看到，通过延迟构建 ECDF 树来回答查询所需的时间与非延迟构建树的过程相比并没有变化。本证明将集中在处理代价中的节点扩展部分。显然，我们不需要考虑 $r > n$ 的情况，因为节点扩展代价不会超过非延迟 ECDF 树的总预处理代价。令 $f(n, r, k)$ 表示在 $k$ 维空间中，使用 $k$ 维 ECDF 树回答 $r$ 个查询时，扩展节点的最坏情况代价。当 $r$ 超过 $n$ 时，我们有 $f(n, r, k) = O\left(n \text{⸱} \log^k n\right)$，因为 $n$ 个查询，每个查询都会导致不同的叶节点，足以完全扩展 ECDF 树。接下来，我们将证明当 $r \leq n$ 时，$f(n, r, k) = O\left(n \text{⸱} \log^k r\right)$。

---

这个归纳的基础是 $k=1$ 的情况。考虑一维 ECDF 树。它是一个最优的二叉搜索树，我们可以引用定理 3 来证明该定理的有效性。这确立了我们关于 $k$ 的归纳基础，换句话说，当 $r \leq n$ 时，$f(n, r, 1) = O(n \text{⸱} \log r)$。归纳假设是该结果在最多 $k-1$ 维时是有效的，即当 $r \leq n$ 时，$f(n, r, k-1) = O\left(n \text{⸱} \log^{k-1} r\right)$。现在我们证明它对于 $k$ 维也必须是有效的。在我们嵌套归纳的第二层中，我们专注于 $k$ 维 ECDF 树，并对 $n$ 进行归纳。显然，当 $n=1$ 时，$k$ 维 ECDF 树会满足上述定理，前提是 $r \leq n$。现在我们假设该结果对于最多 $n-1$ 个点的 $k$ 维情况有效。为了完成证明，我们展示在给定的假设下，结果可以扩展到 $n$ 个点的 $k$ 维情况。

---

考虑 $P$ 中 $n$ 个点的 $k$ 维 ECDF 树的根节点，记为 $V$。它包含一个中位超平面，记为 $M_V$，该超平面将 $P$ 中的 $n$ 个点划分为两个相等的子集 $P_1$ 和 $P_2$。回想一下，$P_1$ 是 $P$ 中所有位于 $M_V$ 以下的点的集合；$P_2$ 是 $P$ 中所有位于 $M_V$ 以上的点的集合。$V$ 的左子树和右子树分别是 $P_1$ 和 $P_2$ 的 $k$ 维 ECDF 树。我们还在 $V$ 存储一个 $(k-1)$ 维 ECDF 树，记为 $T_1$，它用于存储 $P_1$ 中点在 $M_V$ 上的投影。这个低维树在 $P_1$ 和 $P_2$ 之间创造了一种不对称性。这个不对称性可能会使我们的证明变得相当复杂。因此，为了本证明的目的，我们将对 ECDF 树的结构做一个简化假设。我们假设 $V$ 还包含一个 $(k-1)$ 维 ECDF 树，记为 $T_2$，它用于存储 $P_2$ 中点在 $M_V$ 上的投影。

---

ECDF 树的搜索过程也进行了修改，引入了对称性。给定一个查询 $q$，我们首先根据中位超平面 $M_V$ 测试它。如果它位于 $M_V$ 之上，则搜索继续在 $V$ 的右子树和 $T_1$ 中进行。另一方面，如果 $q$ 位于 $M_V$ 之下，我们将在 $V$ 的左子树和 $T_2$ 中继续搜索。搜索 $T_2$ 是多余的，因为 $q$ 位于 $M_V$ 以下，不能支配 $P_2$ 中的任何点。这些修改不仅在根节点处进行，而是在 ECDF 树中的所有节点处进行。很容易看出，这些修改只能增加我们节点扩展算法的运行时间。此外，这些更改导致执行冗余操作，但不会改变我们算法的结果。因此，显然，任何针对修改后 ECDF 树的节点扩展成本的上界也适用于原始的延迟数据结构。

---

现在我们继续完成 $r \leq n$ 的归纳证明。令 $r_1$ 表示位于中位超平面 $M_V$ 以下的查询数量。这些查询会在根节点的左子树中继续搜索。令 $r_2 = r - r_1$ 表示剩余的查询，它们位于中位超平面 $M_V$ 之上，因此继续在右子树中搜索。考虑处理这些查询所涉及的节点扩展成本。找到中位超平面 $M_V$ 需要 $O(n)$ 次操作。位于 $M_V$ 以下的 $r_1$ 个查询在 $V$ 的左子树（一个包含 $n / 2$ 个点的 $k$ 维 ECDF 树）和 $T_2$（一个包含 $n / 2$ 个点的 $(k-1)$ 维 ECDF 树）中处理。剩下的 $r_2$ 个查询则在 $V$ 的右子树（一个包含 $n / 2$ 个点的 $k$ 维 ECDF 树）和 $T_1$（一个包含 $n / 2$ 个点的 $(k-1)$ 维 ECDF 树）中处理。这为我们提供了以下关于处理 $r$ 个查询所涉及的总节点扩展成本的上界：

$\begin{aligned}
f(n, r, k)= & \max _{r_1+r_2=r}\left\{f\left(\cfrac{n}{2}, r_1, k\right)+f\left(\cfrac{n}{2}, r_2, k\right)+f\left(\cfrac{n}{2}, r_1, k-1\right)\right. 
\left.+f\left(\cfrac{n}{2}, r_2, k-1\right)+O(n)\right\} .
\end{aligned}$ 

---

使用归纳假设，我们知道不等式右侧函数的确切形式。特别地，我们知道这些函数是凸的。这意味着不等式的右侧在 $r_1 = r_2 = r / 2$ 时取得最大值。综合所有这些，我们得到了期望的结果：

$f(n, r, k)=O\left(n \text{⸱} \log ^k r\right), \quad r \leqq n .$

再次注意，这个结果仅在固定 $k$ 的情况下有效，并且 $n$ 是 2 的幂。在一般情况下，$O$ 结果中的常数依赖于 $k$。Monier 对 Bentley 算法的详细分析 [9] 也将我们的结果扩展到了任意的 $n$ 和 $k$

---

Bentley [2] 实际上对构建 ECDF 树的预处理时间有一个稍微更好的上界。他利用了预排序技术，将 $k$-维 ECDF 树在 $n$ 个点上的预处理时间上界提高到了 $O\left(n \text{⸱} \log^{k-1} n\right)$。他首先通过第一个坐标对所有 $n$ 个点进行排序，时间复杂度为 $O(n \text{⸱} \log n)$。这个排序在每一步中都得以保持，特别是在将点分成两个子集时，对于某个坐标的中位超平面进行划分。考虑二维 ECDF 树。最开始，所有的 $n$ 个点按照第一个坐标的顺序存储在根节点中。在第一个查询之后，这些 $n$ 个点将按照中位超平面进行划分，并传递到子节点。在这个划分过程中，第一个坐标的顺序被保持。设 $P_1$ 为传递到左子树的点集，$P_2$ 为传递到右子树的点集。在原始的 ECDF 树中，我们会为 $P_1$ 中的点构建一个一维的 ECDF 树并存储在根节点。而现在，我们只需将 $P_1$ 中的点按照第一个坐标的顺序存储在根节点。这一过程会在每个二维 ECDF 树的节点处重复进行。我们现在将二维 ECDF 树作为递归构建 $k$-维 ECDF 树的基本数据结构。实际上，我们已经去除了原来的一维 ECDF 树。构建预排序 $k$-维 ECDF 树的预处理时间变为 $O\left(n \text{⸱} \log^{k-1} n\right) + O(n \text{⸱} \log n)$。这个新的数据结构也可以像之前的结构一样延迟构建，我们得到了以下结果。

---

**定理 12.** 在 $k$-维空间中回答 $r$ 个支配搜索查询的代价是 $O(G(n, r, k))$，其中

$G(n, r, k)= \begin{cases}n \log n+n \log ^{k-1} r+r \log ^k n, & r \leqq n, \\ n \log ^{k-1} n+r \log ^k n, & r>n .\end{cases}$

**证明.** 该证明可以通过对定理 11 的证明进行简单的修改得到。注意，当 $r > n$ 时，预排序的代价被节点扩展的代价所涵盖。

# 6. Conclusion.

延迟数据结构的范式已经应用于一些搜索问题。在所有情况下，我们考虑了在线查询，并在处理查询的过程中构建搜索树。对于所研究的问题，我们的方法在现有的预处理阶段和搜索阶段策略上有所改进。一个有趣的未解问题是设计用于动态数据集的延迟数据结构，在这些数据集中，插入和删除操作可以与查询处理并发进行。

---

最近邻问题 [13] 要求找出与查询点最接近的 $n$ 个数据点。该问题通过使用 Voronoi 图在 $O(\log n)$ 的搜索时间内解决；Voronoi 图的构建时间为 $O(n \log n)$。目前没有已知的自顶向下的分治算法能够最优地构建 Voronoi 图。构建左侧和右侧 $n / 2$ 点的平分线的显然的自顶向下方法（参见 [14] 关于两个点集的平分线的定义）失败了，因为排序就相当于计算这个平分线。因此，是否能够为最近邻搜索问题设计一种延迟数据结构仍是一个有趣的未解问题。值得注意的是，$\S 2$ 的技术可以用于解决一维最近邻问题。