# 4. Planar convex hull and linear programming problems.  

## 4.1. Point membership in a convex hull. 

在本节中，我们考虑以下问题。给定平面中的一组数据点 $P = \left\{ p_1, p_2, \cdots, p_n \right\}$，每个数据点 $p_i$ 由其两个坐标 $p_i = \left( p_{ix}, p_{iy} \right)$ 确定。$P$ 的凸包记作 $\mathrm{CH}(P)$。我们的任务是回答一系列查询：“查询点 $q_j = \left( q_{jx}, q_{jy} \right)$ 是否包含在 $\mathrm{CH}(P)$ 中？”

---

我们首先提出两种基于预处理的方法。对于所有 $r$ 的值，哪种方法都不是最优的。令 $\mathrm{BCH}(P)$ 表示那些位于 $\mathrm{CH}(P)$ 边界上的点。单个查询可以通过以下方式在 $O(n)$ 时间内回答：计算查询点 $q_j$ 到所有数据点的极角。若查询点包含在 $\mathrm{CH}(P)$ 中，当且仅当该角度范围 $\geq 180^{\circ}$。另外，我们可以通过首先在 $O(n \log h)$ 时间内构建 $\mathrm{CH}(P)$ 来回答 $r$ 个查询，其中 $h$ 是 $\mathrm{BCH}(P)$ 中的点数 [6], [11]。然后，选择一个点 $O$，位于 $\mathrm{CH}(P)$ 的内部，并通过从 $O$ 到 $\mathrm{CH}(P)$ 的每个顶点的 $h$ 条半无限直线将平面分成 $h$ 个扇形。每个扇形包含 $\mathrm{CH}(P)$ 边界上的一条边。在任何扇形中，所有位于该边与 $O$ 同侧的点必须位于 $\mathrm{CH}(P)$ 内。为了回答查询，我们首先通过对角度进行二分查找，确定查询点位于哪个扇形中，这需要 $O(\log h)$ 时间。然后，我们可以根据查询点所在扇形的边界测试其是否在 $\mathrm{CH}(P)$ 内。这需要总共 $O((n+r) \text{⸱} \log h)$ 次操作来回答 $r$ 个查询。

---

我们采用延迟数据结构的方法来解决点成员问题，基于的是Kirkpatrick-Seidel的自顶向下凸包算法 [6]。$\mathrm{CH}(P)$ 的边界由上链和下链组成。每条链都是从 $P$ 中的最左点到最右点的一系列边。考虑一条垂直线将 $P$ 分成两个非空子集。这样的直线将与每条链上的恰好一条边相交；这些边被称为与这条直线对应的上切线和下切线。当垂直线将 $P$ 分成大小相等的两个子集时（我们称之为中位线），对应的切线称为 $P$ 的切线。Kirkpatrick 和 Seidel 表明，切线可以通过 $O(|P|)$ 的操作计算得到。

---

接下来，我们描述我们的延迟数据结构。在以下描述中，我们只考虑上链和切线；对下链和切线的推理是类似的。数据结构包含一个二叉搜索树 $T_P$，其中每个内部节点 $v$ 表示 $P$ 的一个子集 $P(v)$（其中 $P(\text{root}) = P$）。与 $v$ 关联的是一个 $x$-区间 $R_v = [x_L(v), x_R(v)]$；$P(v)$ 包含恰好那些 $x$ 坐标位于 $R_v$ 之间的点。我们通过计算 $P(v)$ 的中位线来扩展一个节点。$P(v)$ 的成员被分成两个子集：中位线左边的点和右边的点。这些子集分别与 $v$ 的两个子节点关联。现在可以计算出 $P(v)$ 的切线，所需的时间为 $O(|P(v)|)$ 次操作。可能存在 $R_v$ 两条垂直线所对应的切线在链中相邻的情况。实际上，两个切线可能是相同的。在这些退化情况下，我们不需要重新计算 $P(v)$ 的切线。这些退化情况可以通过 $R_v$ 边界上垂直线所对应的切线来识别（这些切线将由 $v$ 的祖先节点计算得出）。如果在某个节点上发现上切线和下切线都退化，我们将不再扩展该节点；这样的节点将是 $T_P$ 的叶节点。由于每次扩展节点时至少会发现一个新的切线，$T_P$ 的内部节点数（因此也就是叶节点数）永远不会超过 $h$。

---

查询的搜索过程遍历了搜索树中的一条从根到叶的路径。当第一次访问某个节点 $v$ 时，该节点会被扩展。在任何节点 $v$ 上，搜索会根据查询点的 $x$ 坐标决定是否进展到左子节点或右子节点。此外，我们还会测试查询点是否位于 $P(v)$ 的上切线下方（该切线在两侧延伸至无穷远）。如果在搜索路径上的任何节点处该测试失败，我们就知道查询点位于 $\mathrm{CH}(P)$ 之外。对下链/切线也有类似的测试。

---

图 1 展示了一个例子，其中两个查询 $q_1$ 和 $q_2$ 导致了根节点及其两个子节点的扩展。查询 $q_1$ 位于 $P$ 的中位线左侧，并且位于 $P$ 的下切线之上（通过虚线向左延伸）。这导致了 LSon（根节点）被扩展；此时我们发现 $q_1$ 位于左子节点的下切线下方，因此在 $\mathrm{CH}(P)$ 之外。注意，根节点和 LSon（根节点）的下切线在 $P$ 的某个点处相交；这意味着我们在 LSon（根节点）的右子树中将不会再次计算下切线。类似地，查询 $q_2$ 扩展了根节点的右子节点；它被发现位于 RSon（根节点）的上切线和下切线之间，因此位于 $\mathrm{CH}(P)$ 之内。

---

定理 5：处理 $r$ 个凸包成员查询的操作次数为 $O(\Lambda(n, r))$。

证明：$T_P$ 的深度从不超过 $\log n$。此外，$i$ 层的一个节点的扩展时间为 $O\left(n / 2^i\right)$。这符合我们的框架。与定理 2 证明中的分析类似，可以得出该结果。

## 4.2. Intersection of half-spaces.

我们考虑以下问题：确定查询点 $q_j=\left(q_{j x}, q_{j y}\right)$ 是否位于 $n$ 个半平面的交集内。设 $H=\left\{h_1, h_2, \cdots, h_n\right\}$ 为界定这些半平面的直线集合。我们假设每个半平面都包含原点。如果不是，我们可以通过应用适当的线性变换，将原点带入交集的公共区域，这一操作在 $O(n)$ 时间内完成（前提是这些半平面的交集非空）。具体方法是找到交集内部的一个点，并将原点映射到这个可行点上 [8]。我们也可以在 $O(n)$ 时间内测试交集是否为空 [8]。设 $H_i$ 为由直线 $h_i$ 边界所围成的半平面（包含原点）。在本节中，我们假设 $H_i$ 的交集是有界的——在第 4.3 节中，我们将展示如何处理无界交集区域的情况。

---

几何对偶性（或极性）[4], [11] 的概念在解决接下来的两个问题中将非常有用。在平面中，这种对偶性转化为点与直线之间的转换。一个点 $p=(a, b)$ 的对偶是直线 $l_p$，其方程为 $a x + b y + 1 = 0$，反之亦然。一个更直观的定义如图 2 所示。直线 $l_p$ 与从原点到点 $p$ 的连线垂直。如果点 $p$ 到原点的距离为 $d$，那么对偶直线 $l_p$ 距离原点的距离为 $1 / d$，并且方向相反。

---

我们现在将对考虑的半平面交集应用对偶变换。直线 $h_i$ 的对偶是一个点，我们将其记为 $p_i$；这些点的集合记为 $P$。$H_i$ 的交集的对偶是所有不在 $\mathrm{CH}(P)$ 中的点的集合。查询点 $q_j$ 的对偶是直线 $L_j$。当且仅当 $L_j$ 不与 $\mathrm{CH}(P)$ 相交时，查询点 $q_j$ 才在 $H_i$ 的交集中。因此，我们的问题转化为判断一系列查询直线是否与一组点的凸包相交。

---

搜索树和节点扩展过程与第 4.1 节完全相同。在每个节点 $v$，我们计算查询线 $L_j$ 与 $P(v)$ 的中位线的交点。我们知道，如果以下任意条件成立，$L_j$ 必须与 $\mathrm{CH}(P)$ 相交：（1）交点位于 $P(v)$ 的上下切线之间；（2）$L_j$ 与当前节点的某个切线相交。如果都不满足，我们必须继续在 $v$ 的左子节点或右子节点中搜索，具体取决于 $L_j$ 与切线的斜率。这三种情况分别由图 3 中的线 $L_1, L_2$ 和 $L_3$ 表示。对于 $L_3$，我们看到 $L_3$ 与 $\mathrm{CH}(P)$ 的任何交点必须位于中位线的左侧；因此，我们继续在 LSon $(v)$ 中进行搜索。

以下定理得出： 定理 6：处理 $r$ 个半平面交集查询的操作次数为 $O(\Lambda(n, r))$。

## 4.3. Two-variable linear programming. 

设 $L(f)$ 为一个具有 $n$ 个约束的两变量线性规划问题，目标函数为 $f$，需要在这些约束下最小化 $f$。Dyer [5] 和 Megiddo [8] 的算法可以在 $O(n)$ 时间内找到单个目标函数的最优解。我们考虑线性规划问题的查询版本。每个查询是一个目标函数 $f_i$，要求我们解决 $L\left(f_i\right)$。

---

该问题的预处理方法包括找到由约束定义的半平面的交集。通过分治法可以在 $O(n \log n)$ 时间内完成。将半平面集合划分为大小几乎相等的两部分。在每个子问题中递归地找到半平面的交集；然后可以在线性时间内合并两个交集 [11]。随后，通过对目标函数斜率进行二分查找，可以在 $O(\log n)$ 时间内回答每个查询。

---

与之前一样，我们借助几何对偶性来解决此问题。我们可以再次假设可行区域 $R_L$ 非空且包含原点。每个约束定义了一个半平面 $H_i$；$R_L$ 是这些半平面的交集。使用 $\S 4.1$ 的符号表示，$R_L$ 的对偶是 $\mathrm{CH}(P)$ 的外部区域。

---

首先，我们假设 $R_L$ 是有界的。这意味着在对偶平面中，原点位于 $\mathrm{CH}(P)$ 内。目标函数 $f_i$ 可以看作是原问题中的一族平行直线。根据 $f_i$ 的斜率，我们只需考虑原点上方或下方的平行直线集合。该集合的直线在对偶平面中对应于一条半无限直线，原点为其一端。我们称这条直线为目标线 $g_i$，并注意到它与 $\mathrm{CH}(P)$ 的边界在一个点相交，该点对应于最优解。

---

搜索树和节点扩展与 $\S 4.2$ 中相同。在某个节点 $v$ 处进行搜索时，我们计算 $g_i$ 与 $P(v)$ 的中位线的交点（如果有的话）。如果没有交点，或者交点不在切线之间，则根据原点位于中位线的左侧（右侧），搜索将继续向左（右）子节点进行。否则，我们向相反方向继续搜索。如果 $g_i$ 与 $P(v)$ 的切线相交，搜索结束。

---

当 $R_L$ 是无界时，对偶平面中的原点不位于 $\mathrm{CH}(P)$ 内。如果 $g_i$ 不与 $\mathrm{CH}(P)$ 相交，则问题的解是无界的。这可以通过在 $O(n)$ 时间内计算从原点到 $P$ 中所有点的极角来检测；这在开始时执行一次。如果 $g_i$ 位于该角度范围定义的圆锥体外，则它不与 $\mathrm{CH}(P)$ 相交。如果 $g_i$ 与 $\mathrm{CH}(P)$ 相交，我们使用与有界情况下相同的搜索过程。对偶平面中，两个在原点处的极端角度之间的点在 $\mathrm{BCH}(P)$ 中由一条切线连接。对于上述终止标准，忽略与该切线的交点。

---

图 4 显示了一个无界可行区域及其对应的对偶凸包。图中展示了两个目标函数 $f_1$ 和 $f_2$ 以及它们的对偶目标线。对偶平面中的弧表示那些不与 $\mathrm{CH}(P)$ 相交的目标线（例如，$g_2$），因此它们具有无界的最优解。

定理 7. 处理 $r$ 个二变量线性规划查询的操作数为 $O(\Lambda(n, r))$。

## 4.4. Lower bounds under the algebraic tree model.

$\S 2$ 中的信息论下界对于我们在本节中考虑的几何问题并不适用。在 $\S 2$ 中，我们使用了比较树计算模型，而在这里我们允许使用算术运算。因此，我们使用代数树计算模型 [1]。

---

代数计算树是一种决定输入向量（在 $\mathbf{R}^n$ 中的一个点）是否属于点集 $W \subseteq \mathbf{R}^n$ 的算法。树中的节点有三种类型：计算节点、分支节点和叶节点。计算节点有一个子节点，可以执行一个常规的算术操作或计算平方根。分支节点的行为类似于比较树中的节点，即它可以与之前计算的值进行比较，并且根据比较结果有两个子节点。叶节点被标记为 "接受" 或 "拒绝"，并且没有子节点。每个加法运算、减法运算或乘以常数的操作的费用为零。其他任何操作或比较的费用为单位成本。代数计算树的复杂度是从根节点到叶节点路径上的最大成本和。如果 $W \subseteq \mathbf{R}^n$，则 $C(W)$ 表示 $W$ 的复杂度，是接受精确集 $W$ 的树的最小复杂度。对于任何点集 $S \subseteq \mathbf{R}^n$，令 #($S$) 表示 $W$ 的连通分支数。文献 [1] 中证明了 $C(W)=\Omega(\log \#(W))$。

---

我们现在展示对于处理 $r$ 个凸包成员查询在 $n$ 个数据点上的代数运算下界，时间复杂度为 $\Omega((n+r) \text{⸱} \log \min {n, r})$。事实上，我们将证明这个下界在离线处理 $r$ 个查询时成立。这个下界是通过从集合不相交问题（SET DISJOINTNESS）进行归约得到的，定义如下：给定两个集合 $X=\left\{x_1, x_2, \cdots, x_n\right\}$ 和 $Q=\left\{q_1, q_2, \cdots, q_r\right\}$，确定它们的交集是否非空。这个问题是 $\S 2$ 中提到的集合交集问题（SET INTERSECTION）的简化版本。我们首先证明集合不相交问题的下界。

---

**定理 8**. 任何解决集合不相交问题（SET DISJOINTNESS）的代数计算树，其复杂度必须为 $\Omega((n+r) \text{⸱} \log \min {n, r})$。

**证明**. 假设没有失去一般性，我们令 $r \leq n$。每个集合不相交问题的实例可以表示为一个点 $\beta = (x_1, \cdots, x_n, q_1, \cdots, q_r)$，其中 $\beta$ 位于 $\mathbf{R}^{n+r}$ 空间中。设 $W \subseteq \mathbf{R}^{n+r}$ 为所有表示不相交集合的点的集合。该问题的复杂度为 $\Omega(\log \#(W))$，其中 $\#(W)$ 是集合 $W$ 的连通分量数量 [1]。考虑那些 $q_i$ 不同的实例。集合 $Q$ 的元素可以按顺序排列为 ${q_{(1)} < q_{(2)} < \cdots < q_{(r)}}$，其中 $(i)$ 表示集合 ${q_1, \cdots, q_r}$ 中第 $i$ 小的值的索引。令 $S_\beta(i) = {x_k : q_{(i)} < x_k < q_{(i+1)}}$，对于 $1 \leq i \leq r-1$。定义 $W^* = {\beta : |S_\beta(i)| = \lfloor n / (r-1) \rfloor, 1 \leq i \leq r-1}$，则 $W^* \subseteq W$。$W^*$ 中不同选择的 $S_\beta$ 集合由形如 $x_i = q_j$ 的超平面分隔。这些超平面完全与 $W$ 不相交。这意味着，如果 $W^*$ 中的两个点被这些超平面分隔，那么它们在 $W$ 中也必须被分隔。因此，$W$ 的连通分量数至少与将 ${x_1, x_2, \cdots, x_n}$ 按照 $S_\beta$ 的定义进行划分的方式数相同。通过计数论的论证可以得到，这个数量至少为

$r!\cfrac{n!}{(\lfloor(n / r-1)\rfloor!)^{r-1}} .$

由此可以得出，该问题的复杂度为 $\Omega((n+r) \text{⸱} \log r)$。

---

**定理 9**. 处理 $r$ 个凸包成员查询的复杂度是 $\Omega((n+r) \text{⸱} \log \min {n, r})$。

**证明**. 通过从集合不相交问题（SET DISJOINTNESS）进行 $O(n+r)$ 时间的归约。假设两个集合的元素都位于区间 $[0, 2\pi)$ 上。每个元素 $x_i$ 映射到单位圆上的一个点 $p_i$，其极坐标为 $\left(1, x_i\right)$。这构成了我们的数据集 $P$；注意到 $\mathrm{BCH}(P) = P$。集合 $Q$ 中的每个元素 $q_j$ 映射到一个点 $r_j$，其极坐标为 $\left(1, q_j\right)$。点 $r_j$ 位于 $\mathrm{CH}(P)$ 中当且仅当 $q_j \in X$。因此，集合不相交问题 $\alpha_{n+r}$ 等价于凸包成员查询（HULL_MEMBERSHIP）。

这个下界扩展到了 $\S\S 4.2$ 和 4.3 中的问题。

## 4.5. Effect of the number of points on the convex hull. 

在本节中，我们回到确定查询点是否位于给定 $n$ 个数据点的凸包内的问题。我们展示了当凸包边界上的数据点数 $h$ 远小于 $n$ 时，可以实现显著的改进。显然，当 $h$ 较小时，定理 4 的保证太弱，因为通过 Kirkpatrick-Seidel 算法，可以在 $O(n \log h)$ 操作内找到 $\mathrm{CH}(P)$；随后，查询可以在 $O(\log h)$ 时间内得到答案。这为回答 $r$ 个查询提供了 $O((n+r) \log h)$ 的时间上界。这似乎与定理 9 的下界相矛盾，但请记住，在下界的归约中，所有 $n$ 个数据点都位于凸包的边界上。当 $r$ 超过 $h$ 时，$\S 4.1$ 中的算法可以实现时间上界 $O(n \log h + r \log n)$，因为节点扩展的成本仅为 $O(n \log h)$。然而，搜索的成本不幸的是随着 $r \log n$ 增长，因为尽管叶子节点数只有 $h$，但 $T_P$ 的深度可能随着 $\log n$ 增长。

---

为了绕过这个困难，我们以交错的方式构造两个二叉搜索树 $T_P$ 和 $T_D$。让 $T$ 为算法 $\S 4.1$ 构造的搜索树的完全展开版本。它有 $h$ 个叶子，并且可以在 $O(n \log h)$ 时间内构造。树 $T_P$ 和 $T_D$ 将是 $T$ 的部分展开版本。$T_P$ 是通过按照 $\S 4.1$ 中的算法处理查询得到的版本。另一个树 $T_D$ 是通过延迟深度优先遍历部分构造 $T$ 得到的。

---

深度优先遍历一个具有 $l$ 个叶子的树可以看作由 $l$ 个阶段组成，每个阶段以到达一个新的叶子为结束。类似地，$T_D$ 的深度优先构造可以分解为 $h$ 个阶段。这些 $h$ 个阶段与在搜索树 $T_P$ 上处理前 $h$ 个查询的过程交织在一起。每个阶段也可以看作是在树 $T_D$ 上处理一个明智选择的查询。因此，$T_D$ 的延迟构造的成本与 $T_P$ 相同的上界。

---

当 $r$ 超过 $h$ 时，在处理完 $T_P$ 上的前 $h$ 个查询后，树 $T_D$ 将完全构建完成。此时，$T_P$ 本身可能尚未完全展开；事实上，它可能只展开了一个叶子节点。由于 $\mathrm{CH}(P)$ 现在已由 $T_D$ 完全确定，我们可以在进一步处理查询时不再使用这两棵搜索树。我们现在可以采用楔形法来回答每个查询，时间为 $O(\log h)$（见 §4.1）。由于构造 $T_D$ 的成本为 $O(n \log h)$，因此得出以下定理。

---

**定理 10** 处理 $r$ 个凸包成员查询的成本是 $O\left(\Lambda^{\prime}(n, r, h)\right)$，其中

$\Lambda^{\prime}(n, r, h)= \begin{cases}n \log r, & r \leqq h, \\ (n+r) \text{⸱} \log h, & r>h .\end{cases}$ 

类似的结果适用于 $\S\S 4.2$ 和 4.3 中的问题。