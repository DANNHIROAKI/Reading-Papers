#  0. Abstract

我们提出了一种树形数据结构，用于在一般的 $n$ 点度量空间（其中数据集由 $n$ 个点组成）中快速执行最近邻操作。无论度量的结构如何，该数据结构都仅需 $O(n)$ 的空间，但同时保留了导航网络 [KL04a] 的所有性能特性。如果点集具有有限的扩展常数 $c$（这是一种内在维度的度量，定义见 [KR02]），则覆盖树数据结构可以在 $O\left(c^{6} n \log n\right)$ 时间内构建完成。此外，最近邻查询的时间仅与 $n$ 的对数成比例，具体为 $O\left(c^{12} \log n\right)$ 时间。我们的实验结果表明，与暴力搜索相比，在自然机器学习数据集上，该方法的加速效果从一个数量级到多个数量级不等。


# 1. Introduction

**问题描述.** 最近邻搜索是一种基本的计算工具，尤其在机器学习中具有重要意义。通常认为，高维数据集可能具有低维的内在结构。在本文中，我们研究如何利用数据集中的潜在结构来加速最近邻计算。这种加速能够为许多机器学习算法带来益处，包括基于低维结构假设的降维算法以及依赖于最近邻操作的分类算法（例如 [LMS05]）。基本的最近邻问题描述如下：给定一个度量空间 $(X, d)$ 中的点集 $S$，其大小为 $n$，问题是对 $S$ 进行预处理，使得对于给定的查询点 $p \in X$，能够高效地找到一个点 $q \in S$，使得 $d(p, q)$ 最小。

------

**背景.** 对于一般的度量空间，要找到（甚至是近似找到）一个点的最近邻需要 $\Omega(n)$ 的时间。经典的例子是均匀度量，其中每对点的距离几乎相同，因此没有结构可以利用。然而，实际中感兴趣的度量通常具有一定的结构，可以利用这些结构实现显著的计算加速。受这一观察的启发，已经提出了若干度量结构的概念以及利用这些结构的算法 [Cla99, KR02, KL04a]。

---

设 $S \subset X$ 中，以 $p$ 为中心、半径为 $r$ 的闭球记为 $B_{S}(p, r)={q \in S : d(p, q) \leq r}$。在上下文明确的情况下，可以省略下标 $S$。Karger 和 Ruhl [KR02] 提出了基于点扩展的维度概念，并针对此维度较小的度量空间描述了一种随机算法。$S$ 的扩展常数定义为满足以下条件的最小值 $c \geq 2$：对于任意 $p \in X$ 和 $r > 0$，都有 $\left|B_{S}(p, 2r)\right| \leq c \left|B_{S}(p, r)\right|$。如果 $S$ 均匀分布在某维度为 $d$ 的曲面上，则 $c \sim 2^{d}$，这启发我们将 $S$ 的扩展维度（也称为 KR 维度）定义为 $\operatorname{dim}_{\mathrm{KR}}(S) = \log c$。然而，正如 [KR02, KL04a] 中先前所观察到的，某些直观上应该被视为低维的度量实际上可能具有很大的增长常数。例如，在欧几里得空间中增加一个点可能导致 KR 维度任意增长（尽管这种情况在实际中可能是病态的）。

------

一种更稳健的替代方法是使用倍增常数 [Cla99, KL04a]，其定义为最小值 $c$，使得 $X$ 中的每个球都可以用 $X$ 中 $c$ 个半径减半的球覆盖。$S$ 的倍增维度定义为 $\operatorname{dim}_{\mathrm{KL}}(S) = \log c$。正如 [GKL03] 所示，这一概念比 KR 维度更为广泛。然而，目前使用倍增维度的一个缺点是，只能证明较弱的结果，且这些结果仅适用于近似最近邻问题。

---

上述算法的查询时间保证仅为 $n$ 的对数级别（同时在其各自的内在维度概念上呈指数增长）。然而，在机器学习应用中，这些理论上令人满意的算法大多仍未被实际使用。当欧几里得维度较小时，通常的做法是使用KD树（参见 [FBL77]）。如果度量是非欧几里得的，或者欧几里得维度较大，球树（参见 [Uhl91, Omo87]）在许多实际应用中表现出色（参见 [GM00]）。然而，这些方法目前仅有 $O(n)$ 的简单查询时间保证，尽管如果存在某种形式的结构，可能可以证明更优的性能。

------

本文的重点是使这些理论上有吸引力的算法更具实际适用性。基于内在维度概念的这些算法的一个显著缺点是，其空间需求在维度上呈指数增长。正如我们在实验中观察到的（见第5节），数据集的维度通常会随着数据集大小的增长而增加，因此空间消耗是一个合理的关注点。这一缺点正是覆盖树（cover tree）所要解决的问题。

---

**新成果。** 我们提出了一种简单的数据结构——覆盖树（cover tree），用于精确和近似的最近邻操作。与其他研究成果 [KR02, KL04a, Cla99, HM04] 相比，该数据结构的优势在于其空间需求与数据集大小呈线性关系，并且独立于任何维度假设。覆盖树的结构简单，因为其操作的数据结构是树；事实上，覆盖树（作为图结构）可以看作是导航网 [KL04a] 的一个子图。覆盖树在保留所有维度相关保证的同时丢弃了导航网的大多数边。由于该结构的算法和证明本质上不同（例如，对树的贪婪遍历无法保证正确回答查询），因此需要采取新的方法。我们还提供了实验结果（见第5节）和公开代码，表明该方法在实际应用中与当前方法具有竞争力。

------

在我们的分析中，主要关注扩展常数（expansion constant），因为这可以为精确最近邻查询提供结果。如果 $S$ 的扩展常数为 $c$，我们可以明确地给出与 $c$ 的依赖关系：

|           | 覆盖树                        | 导航网             | $[$ KR02]          |
| --------- | ----------------------------- | ------------------ | ------------------ |
| 构建空间  | $O(n)$                        | $c^{O(1)} n$       | $c^{O(1)} n \ln n$ |
| 构建时间  | $O\left(c^{6} n \ln n\right)$ | $c^{O(1)} n \ln n$ | $c^{O(1)} n \ln n$ |
| 插入/删除 | $O\left(c^{6} \ln n\right)$   | $c^{O(1)} \ln n$   | $c^{O(1)} \ln n$   |
| 查询      | $O\left(c^{12} \ln n\right)$  | $c^{O(1)} \ln n$   | $c^{O(1)} \ln n$   |

------

需要注意的是，这里的算法（如同 [KL04a] 中的方法，但不同于 [KR02]）在不知道结构信息的情况下也能运行；分析仅是基于这些假设进行的。关于 $c$ 的时间复杂性比较较为微妙（见第4节的讨论）。此外，这种比较在某种程度上并不完全公平，因为过去的研究并未显式尝试优化与 $c$ 的关系。

---

这些算法可以轻松扩展到对于具有有界倍增维度（doubling dimension）集合的近似最近邻查询，与 [KL04a] 中的方法类似。[KL04a] 的算法依赖于纵横比（aspect ratio） $\Delta$，其定义为最大点间距离与最小点间距离的比值。${ }^{1}$ 我们算法的查询时间与 [KL04a] 中相同，即 $O(\log \Delta)+(1 / \epsilon)^{O(1)}$，其中 $\epsilon$ 是近似参数。

------

在扩展版本 [BKL06] 中，我们提供了若干具有实际意义的算法。这些算法包括延迟构建（lazy construction，能够将构建成本分摊到查询中）、批量构建（batch construction，在经验上优于逐点插入的序列操作）以及批量查询（batch query，能够将查询时间分摊到多个查询上）。

------

**组织结构。** 本文其余部分组织如下：第2和第3节详细说明了算法并证明其正确性，且不对数据集中的任何结构作出假设。第4节提供了与维度相关的运行时间分析。第5节展示了实验结果。

## 2. The Cover Tree Datastructure

覆盖树（cover tree）$T$ 是一种针对数据集 $S$ 的分层树结构，其中每一层是其下层的“覆盖”。每一层由一个整数标度 $i$ 索引，标度随着树的向下递进而减小。树中的每个节点都与 $S$ 中的某个点相关联。$S$ 中的每个点可能与树中的多个节点相关联；但我们要求每个点在同一层中最多出现一次。设 $C_{i}$ 表示与第 $i$ 层节点相关联的 $S$ 中的点集。覆盖树遵循以下不变量，对所有 $i$ 均成立：

1. **（嵌套性）** $C_{i} \subset C_{i-1}$。这意味着一旦某点 $p \in S$ 出现在 $C_{i}$ 中，则树的每一更低层中均有与 $p$ 相关联的节点。
2. **（覆盖树）** 对于每个 $p \in C_{i-1}$，存在一个 $q \in C_{i}$，使得 $d(p, q)<2^{i}$，且第 $i$ 层与 $q$ 相关联的节点是第 $i-1$ 层与 $p$ 相关联的节点的父节点。
3. **（分离性）** 对于所有不同的 $p, q \in C_{i}$，有 $d(p, q)>2^{i}$。

------

**重要说明：** 在术语上稍作滥用的情况下，我们将节点与其相关联的点视为相同，但理解上述区别后不会产生混淆。由于每个点在同一层中最多只能出现在一个节点中，因此不会引起歧义。

------

这些不变量与导航网 [KL04a] 中使用的规则基本相同，但在第 (2) 点上有所不同，我们仅要求每个节点有一个父节点，而非所有可能的父节点。（对于导航网中的每个 $i-1$ 层节点，它指向 $i$ 层中所有距离在 $\gamma 2^{i}$ 内的节点，其中 $\gamma \geq 4$ 为某常数。）尽管覆盖树可能丢弃导航网中的大部分链接，但仍能保持所有运行时间性质。

---

从概念上讲，使用覆盖树的隐式表示来描述算法最为简单，该表示包含无限层级，其中 $C_{\infty}$ 包含与根节点关联的 $S$ 中的点，而 $C_{-\infty}=S$。然而，我们必须使用显式表示并对其进行分析，其空间需求仅为 $O(n)$。回忆一下，如果某点 $p \in S$ 首次出现在第 $i$ 层，则它会出现在第 $i$ 层以下的所有层中。正如以下证明所示，$p$ 在这些层中是其自身的子节点（即，与 $p$ 关联的节点是上一级中与 $p$ 关联节点的子节点）。树的显式表示将所有唯一子节点为自身的节点合并。这意味着，每个显式节点要么有一个非自身的父节点，要么有一个非自身的子节点，从而立即得出 $O(n)$ 的空间上界，与增长常数 $c$ 无关。

------

**定理1（空间上界）** 覆盖树最多需要 $O(n)$ 的空间。

**证明：** 在显式树中，每个点最多只有一个非自身的父节点。为证明这一点，假设 $q \neq p$ 且 $q^{\prime} \neq p$ 是 $p$ 的两个父节点。根据覆盖树的不变量，这两个父节点所在的层级必须不同。嵌套性意味着在某个较低的层级 $j$，$p$ 是其父节点的兄弟节点。如果 $q^{\prime}$ 是较低层级的父节点，那么分离性意味着 $d\left(p, q^{\prime}\right)>2^{j}$，这进一步表明 $q^{\prime}$ 不可能是 $j$ 层的父节点。每当一个点是自身的父节点时，它同时也有另一个点作为其子节点。因此，最多存在 $O(n)$ 条链接和 $n$ 个点，从而证明了空间上界。

## 3. Single Point Operations

We now present the basic algorithms for cover trees and prove their correctness. The runtime analysis is given in Section 4.

### 3.1. Finding the nearest neighbor

为了在覆盖树中找到点 $p$ 的最近邻，我们通过逐层向下遍历树，跟踪一个子集 $Q_{i} \subset C_{i}$，该子集中的节点可能包含 $p$ 的最近邻作为其后代。算法通过扩展 $Q_{i}$ 到其在 $C_{i-1}$ 中的子节点，逐步构建 $Q_{i-1}$，然后丢弃任何无法指向 $p$ 最近邻的子节点。为了简化思考，可以将树看作具有无限层级（其中 $C_{\infty}$ 只包含根节点，且 $C_{-\infty}=S$）。将节点 $p$ 的子节点集合表示为 Children$(p)$，并设 $d(p, Q)=\min _{q \in Q} d(p, q)$ 为点 $p$ 到集合 $Q$ 中最近点的距离。注意，尽管算法是在隐式表示上通过无限循环来描述的，但它实际上只需要在显式表示上进行操作。

------

**定理 2** 如果 $T$ 是 $S$ 上的覆盖树，FindNearest$(T, p)$ 将返回 $p$ 在 $S$ 中的最近邻。

**证明：** 对于 $C_{i-1}$ 中的任何点 $q$，$q$ 和其任何后代 $q^{\prime}$ 之间的距离有上界：$d\left(q, q^{\prime}\right) \leq \sum_{j=i-1}^{-\infty} 2^{j} = 2^{i}$。因此，步骤 2(b) 永远不会丢弃 $p$ 最近邻的祖父节点。最终，$Q_{i}$ 中没有不属于 $Q_{i}$ 的后代，因此最近邻一定在 $Q_{i}$ 中。

### 3.2. Approximating the nearest neighbor

覆盖树结构也可以用于近似最近邻查询。给定一个点 $p \in X$ 和某个 $\epsilon > 0$，我们希望找到一个点 $q \in S$，使得 $d(p, q) < (1 + \epsilon) d(p, S)$。其主要思路是维护一个下界和一个上界，当由这些界限所决定的区间足够小时停止。根据对倍增常数的分析，时间复杂度的证明与 [KL04a] 中的基本相同。空间复杂度现在是线性的（与倍增常数无关），从而严格改进了 [KL04a] 中的结果。

------

**算法：**唯一的变化是在第 2 行，代替一直遍历树直到 $Q_{i}$ 中没有节点是显式的，我们在满足 $2^{i+1}(1 + 1 / \epsilon) \leq d\left(p, Q_{i}\right)$ 时停止。

**正确性证明：** 假设遍历在第 $i$ 层终止。那么，要么满足 $2^{i+1}(1 + 1 / \epsilon) \leq d\left(p, Q_{i}\right)$，要么 $Q_{i}$ 中的所有节点都是隐式的（在这种情况下，我们实际上返回的是精确的最近邻）。我们考虑前者的情况。由于 $Q_{i}$ 与 $p$ 的精确最近邻的距离至多为 $2^{i+1}$（定理 2），并且距离满足三角不等式，我们有 $d\left(p, Q_{i}\right) \leq d(p, S) + 2^{i+1}$。结合 $2^{i+1}(1 + 1 / \epsilon) \leq d\left(p, Q_{i}\right)$，我们得到 $2^{i+1}(1 + 1 / \epsilon) \leq d(p, S) + 2^{i+1}$，即 $2^{i+1} \leq \epsilon d(p, S)$。因此，我们得到 $d\left(p, Q_{i}\right) \leq (1 + \epsilon) d(p, S)$。

------

时间复杂度可以从 [KL04a] 中的引理 2.6 中推导得到。近似查询的时间复杂度最多为 $c^{O(1)} \log \Delta + (1 / \epsilon)^{O(\log c)}$，其中 $c$ 是倍增常数，$\Delta$ 是纵横比。

### 3.3. Single Point Insertion

插入算法（算法 2）类似于查询算法，但它是递归地描述的。在这里，$Q_{i}$ 是第 $i$ 层的一个点的子集，这些点可能包含新点 $p$ 作为后代。算法从根节点开始，$Q_{\infty} = C_{\infty}$。正确性证明表明，结构总是能够存在。

------

**定理 3** 给定一个包含根节点 $C_{\infty}$ 的覆盖树 $T$，执行 $\operatorname{Insert}\left(p, C_{\infty}, \infty\right)$ 将返回一个包含点 $p$ 的覆盖树 $S \cup {p}$。

**证明：** 我们证明该算法能够插入任何不在覆盖树中的点 $p$。（如果 $p$ 已经在树中，可以通过一次搜索操作确定。）集合 $Q$ 从非空开始。由于 $p$ 不在树中，$d(p, S)$ 不为零，并且第 2 行的条件最终会成立。由于根节点的尺度是 $\infty$，存在一个最小尺度 $i$，该尺度介于 $\infty$ 和第 2 行首次成立的尺度之间，满足 $d\left(p, Q_{i}\right) \leq 2^{i}$，因此第 3(b) 步成立。

------

现在我们证明插入操作保持所有的覆盖树不变性。如果 $p$ 被插入到第 $i-1$ 层，我们知道 $d\left(p, Q_{i}\right) \leq 2^{i}$，因此我们总是可以找到一个父节点 $q \in Q_{i}$，满足 $d(p, q) \leq 2^{i}$，从而满足覆盖树不变性。一旦 $p$ 被插入到第 $i-1$ 层，它会隐式地被插入到每个下面的层（作为上一层的自子节点），从而保持嵌套不变性。接下来我们证明这样做不会违反下层的分离条件。

------

为了证明第 $i-1$ 层的分离条件，考虑 $q \in C_{i-1}$。如果 $q \in Q$，则 $d(p, q) > 2^{i-1}$。如果 $q \notin Q$，则在某次迭代中，$i' > i$ 时，$q$ 的某个父节点，记作 $q' \in C_{i'-1}$，被删除（在第 3(a) 步），这意味着 $d(p, q') > 2^{i'}$。利用第 $j$ 层的覆盖树不变性，我们有 $d(p, q) \geq d(p, q') - \sum_{j=i'-1}^{i} 2^j = d(p, q') - (2^{i'} - 2^i) = 2^{i'} - (2^{i'} - 2^i) = 2^i$，这证明了所需的分离条件 $d(p, C_{i-1}) > 2^{i-1}$。下层的分离条件可以类似地证明。

### 3.4. Single Point Removal

删除操作（算法 3）类似于插入操作，但由于需要处理被删除节点的子节点，因此稍微复杂一些。

**定理 4** 给定一个覆盖树 $T$，执行 $\operatorname{Remove}\left(p, {C_{\infty}}, \infty\right)$ 将返回一个包含 $S - {p}$ 的覆盖树。

(a) 从 $C_{i-1}$ 中删除 $p$，并从其父节点的子节点列表中删除 $p$。
 (b) 对于每个 $q \in \operatorname{Children}(p)$，执行以下操作。

**证明：** 如同之前，集合 $Q_{i}$ 维护第 $i$ 层中离 $p$ 最近的点，在我们通过树的过程中逐级下降并减少 $i$ 时。递归在达到某个层次时停止，此时 $p$ 总是隐式存在于该层以下。

------

对于每个显式包含 $p$ 的层 $i$，我们从 $C_{i}$ 中删除 $p$，并从 $C_{i+1}$ 中其父节点的子节点列表中删除 $p$。这样做不会破坏嵌套和分离不变性。对于 $p$ 的每个子节点 $q$（此时 $p$ 已经从其子节点列表中删除），我们向上遍历树寻找一个新的父节点。更准确地说，如果在某层 $i$ 中存在一个节点 $q' \in C_{i}$，使得 $d(q, q') \leq 2^i$，我们就将 $q'$ 设为 $q$ 的父节点；否则，我们将 $q$ 插入到 $C_i$ 层，并重复这一过程，直到找到一个父节点为止。插入操作不会违反分离和嵌套约束，因为 $d(q, C_i) > 2^i$（否则我们就不会将 $q$ 插入到 $C_i$ 层）。这个传播过程是保证终止的，因为 $q$ 被根节点覆盖（在根节点的尺度下）。因此，覆盖树不变性会对 $p$ 的所有子节点得到保持。

## 4. The Runtime Analysis

在本节中，隐式表示和显式表示之间的区别（见第 2 节）是重要的。我们从三个引理开始，讨论覆盖树的一些结构性质。

---

**引理 4.1（宽度界限）** 任意节点 $p$ 的子节点数目被 $c^4$ 所界限。

**证明：** 设 $p$ 位于第 $i$ 层。它的子节点数目最多为 $\left|B\left(p, 2^{i}\right) \cap C_{i-1}\right|$，这显然被 $\left|B\left(p, 2^{i+1}\right) \cap C_{i-1}\right|$ 所界限。证明的思路是，通过限制我们可以将半径为 $2^{i-2}$ 的不重叠球体放入 $B\left(p, 2^{i+1}\right)$ 中的数量。每个这样的球体最多可以覆盖 $C_{i-1}$ 中的一个点，从而界限了子节点的数量。对于 $p$ 的任何子节点 $q$，由于 $d(p, q) \leq 2^{i}$，我们有 $B\left(p, 2^{i+1}\right) \subset B\left(q, 2^{i+2}\right)$，这意味着 $\left|B\left(p, 2^{i+1}\right)\right| \leq \left|B\left(q, 2^{i+2}\right)\right| \leq c^4 \left|B\left(q, 2^{i-2}\right)\right|$。由于 $C_{i-1}$ 中的点之间至少相距 $2^{i-1}$，因此所有的 $B\left(q, 2^{i-2}\right)$ 必须是互不重叠的。我们还知道，每个 $B\left(q, 2^{i-2}\right)$ 都包含在 $B\left(p, 2^{i+1}\right)$ 中，因为 $d(p, q) \leq 2^{i}$。因此，可以将围绕子节点的多个不重叠球体放入 $B\left(p, 2^{i+1}\right)$ 中的数量上限为：

$\left|B\left(p, 2^{i}\right) \cap C_{i-1}\right| \leq \cfrac{\left|B\left(p, 2^{i+1}\right)\right|}{\left|B\left(q, 2^{i-2}\right)\right|} \leq c^{4}$

这就界限了 $p$ 的子节点数目。

---

以下引理在界限树的深度时非常有用。它指出，如果在围绕 $p$ 的某个环形区域内存在一个点，那么围绕 $p$ 的足够大的球体包含这个环形区域时，球体的体积增长是非平凡的。换句话说，它给出了关于体积增长的下界，且该下界是用增长常数 $c$ 来表示的，而 $c$ 的定义提供了一个上界。

---

**引理 4.2（增长界限）** 对于所有点 $p \in S$ 和 $r>0$，如果存在一个点 $q \in S$，使得 $2r < d(p, q) \leq 3r$，则有：

$|B(p, 4 r)| \geq\left(1+\cfrac{1}{c^{2}}\right)|B(p, r)|$

**证明：** 由于 $B(p, r) \subset B(q, 3r + r)$，我们有 $|B(p, r)| \leq |B(q, 4r)| \leq c^2 |B(q, r)|$。由于 $B(p, r)$ 和 $B(q, r)$ 是不相交的，并且它们都是 $B(p, 4r)$ 的子集，我们有 $|B(p, 4r)| \geq |B(p, r)| + |B(q, r)|$。结合这些不等式，得出结论。

---

利用这个结果，我们可以证明任意点 $p$ 的显式深度的界限，显式深度定义为从根节点到 $p$ 的路径中，在 $p$ 显式出现的最低层级上的显式祖父节点的数量。

---

**引理 4.3（深度界限）** 任意点 $p$ 的最大深度为 $O\left(c^2 \log n\right)$。

**证明：** 定义 $S_i = \left\{ q \in S : 2^{i+1} \leq d(p, q) < 2^{i+2} \right\}$。首先我们要证明，如果点 $q \in S_i$ 是点 $p$ 的祖父节点，那么 $q \in C_i$。如果 $q \in C_j$，对于某个 $j$，则它的任何孙节点与 $q$ 的距离最多为 $2^{j+1}$，这意味着 $j \geq i$。根据嵌套性质，$q \in C_i$，因为 $C_j \subset C_i$。

现在我们考虑点 $p$ 在层级 $C_i$、$C_{i+1}$、$C_{i+2}$、$C_{i+3}$ 中的祖父节点。由于树的性质，最多有四个这样的祖父节点。实际上，在层级 $i+3$ 以上，$S_i$ 中不会有其他唯一的祖父节点。回顾一下，如果 $q \in S_i$，那么 $d(p, q) < 2^{i+2}$。如果 $q$ 也在 $C_{i+3}$ 中，根据良好分离性约束，$S_i$ 中就不能有其他点同时在 $C_{i+3}$ 中。根据嵌套性，可以得出结论：如果存在 $j > i+3$ 的祖父节点，它们也会出现在 $C_{i+3}$ 中。

---

因此，任何环形区域 $S_{i}$ 中只能包含唯一的 $p$ 的祖父节点，直到层级 $i+3$。现在，我们只需要限制围绕 $p$ 的所有 $S_{i}$ 的数量，以包含所有点 $S$。为此，应用增长界限，设 $r = \cfrac{d(p, q)}{2}$，其中 $q$ 是 $p$ 的最近邻点，发现 $|B(p, 4r)| \geq \left(1 + \cfrac{1}{c^2}\right) |B(p, r)| = \left(1 + \cfrac{1}{c^2}\right)$。然后，找到下一个最近的点 $q$，使得 $d(p, q) \geq 8r$，并应用增长界限，设 $r' = \cfrac{d(p, q)}{2}$，发现 $|B(p, 4r)| \geq \left(1 + \cfrac{1}{c^2}\right)^2$，因为每次应用增长界限时，都是不相交的（请注意，这个过程可能会显著低估点的数量）。这个过程最多可以重复 $\cfrac{\log n}{\log \left(1 + \cfrac{1}{c^2}\right)}$ 次，直到下界超过 $n$ 的上界。终止时，每个点 $q$ 都可以与最大值 $r$ 关联，满足 $2r \leq d(p, q)$。在该过程中与每一步相关联的点集合位于最多 4 个环形区域 $S_{i}$ 内。因此，围绕任何 $p$ 的非空环形区域最多有 $O\left(\cfrac{\log n}{\log \left(1 + \cfrac{1}{c^2}\right)}\right)$ 个。这是 $O\left(c^2 \log n\right)$，因为 $c \geq 2$。$S_{i}$ 中显式祖父节点的数量是常数，从而完成证明。

---

我们现在可以陈述并证明主要定理。

**定理 5**（查询时间）：如果数据集 $S \cup {p}$ 的扩展常数为 $c$，则 $p$ 的最近邻可以在时间 $O\left(c^{12} \log n\right)$ 内找到。

**证明**：设 $Q^{*}$ 为算法考虑的最后一个显式的 $Q_i$。根据引理 4.3，树中任何点（特别是 $Q^{*}$ 中的任何点）的显式深度有上界 $k = O\left(c^{2} \log n\right)$。因此，迭代次数至多为 $k \left|Q^{*}\right| \leq k \cdot \max_i \left|Q_i\right|$。在每次迭代中，最多需要 $O\left(\max_i \left|Q_i\right|\right)$ 时间来确定哪些元素需要显式下降，这意味着时间上界为 $O\left(k \max_i \left|Q_i\right|^2\right)$。

---

还需要注意的是，在步骤 2(a) 中，遇到的子节点数最多为 $k c^4 \max_i \left|Q_i\right|$，这是根据引理 4.1 得出的。步骤 2(b) 的工作量不超过步骤 2(a)。步骤 3 至多需要 $\max_i \left|Q_i\right|$ 的工作量。因此，运行时间上界为 $O\left(k \max_i \left|Q_i\right|^2 + k \max_i \left|Q_i\right| c^4\right)$，从而完成证明，前提是我们能证明 $\max_i \left|Q_i\right| \leq c^5$。

---

考虑在第 $i$ 次迭代过程中构造的任意 $Q_{i-1}$。回忆一下，$Q = \left\{\operatorname{Children}(q): q \in Q_i\right\}$，并设 $d = d(p, Q)$。我们有

$\begin{aligned}
Q_{i-1} & =\left\{q \in Q: d(p, q) \leq d+2^{i}\right\} =B\left(p, d+2^{i}\right) \cap Q \subseteq B\left(p, d+2^{i}\right) \cap C_{i-1}
\end{aligned}$

其中，第一个等式是根据 $Q_{i-1}$ 的定义得到的，第二个等式是因为 $Q \subseteq C_{i-1}$。

---

先，假设 $d > 2^{i+1}$。则我们有

$\left|B\left(p, d+2^{i}\right)\right| \quad \leq|\quad B(p, 2 d)| \leq c^{2}\left|B\left(p, \cfrac{d}{2}\right)\right|$

现在，由于 $d \leq d(p, S) + 2^i$（由 $Q \subseteq C_{i-1}$ 得到），并且假设 $d > 2^{i+1}$，我们也有 $d(p, S) \geq d - 2^i > 2^i$。因此，$B\left(p, \frac{d}{2}\right) = {p}$，并且 $\left|Q_{i-1}\right| \leq c^2$。

---

剩下的情况是 $d \leq 2^{i+1}$。考虑一个点 $q \in C_{i-1}$，它也在 $B(p, d + 2^i)$ 中。与引理 4.1 的证明类似，我们对可以打包进 $B\left(p, d + 2^i + 2^{i-2}\right)$ 中的半径为 $2^{i-2}$ 的不相交球的数量进行界定。任何这样的球最多只能包含一个点在 $C_{i-1}$ 中（由于分离约束），从而对 $\left|Q_{i-1}\right|$ 进行界定。我们有

$\begin{aligned}
& \quad\left|B\left(p, d+2^{i}+2^{i-2}\right)\right| \leq\left|B\left(q, 2\left(d+2^{i}\right)+2^{i-2}\right)\right| \leq \\
& \left|B\left(q, 2^{i+2}+2^{i+1}+2^{i-2}\right)\right| \leq\left|B\left(q, 2^{i+3}\right)\right| \leq c^{5}\left|B\left(q, 2^{i-2}\right)\right| \\
& \text { and thus }\left|Q_{i-1}\right| \leq\left|B\left(p, d+2^{i}\right) \cap C_{i-1}\right| \leq c^{5} .
\end{aligned}$

---

比较导航网和覆盖树的时间复杂度，特别是它们对扩展常数的依赖性，是一项复杂的任务。我们的数据结构执行了运行时计算，而这些计算在导航网算法的预处理阶段已完成。导航网可以以一种更贪婪的模式（深度优先搜索）运行，而覆盖树则使用一种结合了深度优先和广度优先搜索的方法。这种权衡更为微妙，因为用于构建导航网覆盖的球的半径大于覆盖树中使用的半径，这意味着一个节点可能需要维护更多的子节点。

---

最后，我们分析动态操作。

**定理 6** 任何插入或删除操作的时间复杂度最多为 $O\left(c^{6} \log n\right)$。

**证明：** 首先，我们证明在每个覆盖集中的所有节点，除了一个节点外，要么被扩展为它们的子节点，要么在接下来的两个覆盖集中被删除。之所以这样，注意到每个 $Q_{i}$ 都包含一个以点 $p$ 为中心、半径为 $2^{i+1}$ 的球（根据定义）。固定 $i$，假设某个节点 $q$ 出现在 $Q_{i}, Q_{i-1}, Q_{i-2}$ 中（无论是显式还是隐式）。那么，$Q_{i}$ 中的其他节点 $q^{\prime}$ 就不能出现在 $Q_{i-2}$ 中，因为在第 $i$ 层的分离约束规定了 $d(q, q^{\prime}) > 2^i$，而 $Q_{i-2}$ 中的任何节点与 $q$ 之间的最大距离也只能是 $2^i$。因此，$q$ 要么被删除，要么被扩展到它的子节点，在这种情况下，它必须消耗一个显式深度层。

---

设 $k = c^{2} \log |S|$ 为根据引理 4.3 给出的任何点的最大显式深度。那么，具有显式节点的覆盖集的总数最多为 $4 k$，其中第一个项来自于这样一个事实：任何没有被删除的节点必须在每三次迭代中至少显式一次，而额外的 $k$ 账户是为了一个可能在多次迭代中都是隐式的单独节点。

---

因此，第 1 步和第 2 步的总工作量与 $O\left(k \max *{i}\left|Q*{i}\right|\right)$ 成正比。第 3 步所需的工作量不超过第 1 步。对于每个 $i$，$Q_{i}$ 是假设节点在第 $i+1$ 层的有效子节点集合，因此根据引理 4.1，$\left|Q_{i}\right| \leq c^{4}$。将这些界限相乘得到结果。

---

为了获得删除操作的界限，我们可以使用类似的论证来证明，在查找父节点的过程中，最多只有一个节点可以被传播向上超过两次。因此，算法 3 中的第 5 步最多需要 $O\left(k \max *{i}\left|Q*{i}\right|\right)$ 步。其他步骤所需的工作量不超过插入操作的工作量。

## 5. Experimental Results

我们在多个数据集上测试了该算法，这些数据集来自 UCI 机器学习和 KDD 归档 [UCI]、KDD 2004 决赛 [KDDCup]、Mnist 手写数字识别数据集 [mnist] 和 Isomap "Images" 数据集 [isomap]。对于每个数据集，我们使用欧几里得度量查询了每个点的最近 ${1,2,3,5,10}$ 个邻居。与优化的暴力算法进行比较的结果总结如图 1 所示。对于 $l_{1}$ 度量的结果相似。

---

一个自然的问题是扩展常数是否是分析中的一个相关量度。由于它是所有点的最坏情况下的扩展度量，因此可能不是衡量最近邻搜索（NNS）难度的最佳指标。图 2(b) 显示了两个包含 5000 个点的数据集，它们具有相同的最坏情况下的扩展常数，但在各点的扩展分布上有所不同，结果也不出所料地表现出非常不同的加速效果。图 2(c) 则表明，例如，80 百分位数（基于数据点）的扩展常数似乎是性能的更好预测因子。

---

最后，我们进行了与 Clarkson 的 $s b(S)$ 数据结构 [Cla02] 的比较实验，该数据结构是为与我们的设置相同的场景开发的（详见 [Cla99]）。对于每个数据集，我们使用 [Cla02] 中的“d”方法进行了每个点的精确最近邻查询，该方法被报告为在所有其他方法中表现最优。我们在评估两种算法时包括了构建时间，并使用相同的计时机制和相同的距离函数实现。我们的算法在几乎所有测试的数据集上都显著更快；加速效果如图 3(b) 所示。然而需要注意的是，$s b(S)$ 中的 $k$-最近邻实现是通过固定半径查询的简化方法实现的；可能存在更好的方案，但这并非易事。图 3(a) 显示了在编辑距离下，Cover Tree 相对于 $s b(S)$ 的加速效果（字符串数据）。

---

图 1. 在查询数据集中的每个点的最近 ${1,2,3,5,10}$ 个邻居时，相对于暴力搜索的加速效果（对数尺度）；数据集按字节大小升序排列（用虚线表示）。

图 2. (b) 对于具有相同最大扩展的两个数据集，点的扩展常数的累计分布。我们在 'mnist' 数据集上几乎没有加速，在 bio_test 数据集上大约加速了 10 倍。(c) 在各种 5000 点数据集上，与最坏情况下的扩展常数和 80 百分位扩展常数的加速效果，这些数据集是从 [UCI, KDDCup, mnist, isomap] 中的数据集前缀得到的。

图 3. 相对于 $s b(S)$ [Cla02] 的加速效果（对数尺度）：(a) 数据集中的每个点的 NNS；点是编辑距离下的字符串。虚线显示了构建时间的相应加速效果。(b) (1,2)-NNS（实线和虚线分别表示）。由于解析问题，缺少一个数据点。
