# 布谷鸟过滤器：实际应用中优于布隆过滤器

#### 摘要

在许多网络系统中，布隆过滤器被用于高速集合成员测试。它们允许少量的误报，并且具有非常好的空间效率。然而，它们不支持从集合中删除元素，之前尝试扩展“标准”布隆过滤器以支持删除的操作都在空间或性能上有所下降。

---

我们提出了一种新的数据结构，称为布谷鸟过滤器，它可以替代布隆过滤器用于近似集合成员测试。布谷鸟过滤器支持动态添加和删除元素，并且在性能上甚至优于布隆过滤器。对于存储大量元素且目标误报率适中的应用场景，布谷鸟过滤器比空间优化的布隆过滤器具有更低的空间开销。我们的实验结果还表明，布谷鸟过滤器在时间和空间上都显著优于之前扩展布隆过滤器以支持删除操作的数据结构。

## 1. 引言

许多数据库、缓存、路由器和存储系统使用近似集合成员测试来判断给定项是否在（通常很大的）集合中，并允许一定的误报概率。用于此测试的最广泛使用的数据结构是布隆过滤器 [3]，由于其内存效率高，它已被广泛研究。布隆过滤器已被用于：减少概率路由表中的空间需求 [25]；加速 IP 地址的最长前缀匹配 [9]；改进网络状态管理和监控 [24, 4]；在数据包中编码组播转发信息 [15]，以及许多其他应用 [6]。

---

标准布隆过滤器的一个局限性是，在不重建整个过滤器（或可能引入通常不太理想的漏报）的情况下，无法删除现有项。一些方法扩展了标准布隆过滤器以支持删除，但会带来显著的空间或性能开销。计数布隆过滤器 [12] 已被建议用于多种应用 [24, 25, 9]，但它们通常需要使用 $3-4 \times$ 的空间来保持与空间优化的布隆过滤器相同的误报率。其他变体包括 d-left 计数布隆过滤器 [5]，其空间开销仍然比布隆过滤器大 $1.5 \times$，以及商过滤器 [2]，它通过显著降低查找性能来实现与布隆过滤器相当的空间开销。

---

本文表明，在近似集合成员测试中支持删除操作并不需要比标准布隆过滤器更高的空间或性能开销。我们提出了布谷鸟过滤器，这是一种实用的数据结构，具有四大优势。

1. 它支持动态添加和删除项；  
2. 即使接近满容量（例如，使用了 $95\%$ 的空间），它也能提供比传统布隆过滤器更高的查找性能；  
3. 它比商过滤器等替代方案更易于实现；  
4. 在许多实际应用中，如果目标误报率 $\epsilon$ 小于 $3\%$，它比布隆过滤器使用更少的空间。

---

布谷鸟过滤器是布谷鸟哈希表 [21] 的一种紧凑变体，它仅为每个插入的项存储指纹——通过哈希函数从项中导出的位串，而不是键值对。过滤器被密集地填充了指纹（例如，95\% 的条目被占用），这赋予了它很高的空间效率。对项 $x$ 的集合成员查询只需在哈希表中搜索 $x$ 的指纹，如果找到相同的指纹，则返回 true。

---

在构建布谷鸟过滤器时，其指纹大小由目标误报率 $\epsilon$ 决定。较小的 $\epsilon$ 值需要更长的指纹以拒绝更多的误报查询。有趣的是，虽然我们证明布谷鸟过滤器在许多实际工作负载中比布隆过滤器更优，但它在渐进性上更差：布谷鸟过滤器中使用的最小指纹大小随着表中条目数量的增加而呈对数增长（如第 4 节所述）。因此，对于更大的表，每个项的空间开销更高，但这种额外空间的使用带来了更低的误报率。对于实际应用中包含数十亿项或更少的问题，当 $\epsilon<3\%$ 时，布谷鸟过滤器在支持删除的同时比不可删除的空间优化布隆过滤器使用更少的空间。

---

布谷鸟过滤器与常规哈希表有显著不同，因为过滤器中仅存储指纹，每个项的原始键和值位不再可检索。由于未存储完整的键，布谷鸟过滤器甚至无法执行标准的布谷鸟哈希来插入新项，因为标准布谷鸟哈希涉及根据哈希值移动现有键。这一差异意味着适用于布谷鸟哈希的标准技术、分析和优化不一定适用于布谷鸟过滤器。

本文的技术贡献包括：

- 应用部分键布谷鸟哈希——标准布谷鸟哈希的一种变体——构建支持动态添加和删除项的布谷鸟过滤器（第 3 节）。
- 探讨部分键布谷鸟哈希为何能确保在大多数实际应用中获得高表占用率的原因（第 4 节）。
- 优化布谷鸟过滤器，使其在空间效率上优于布隆过滤器（第 5 节）。

## 2. 背景与相关工作

### 2.1 布隆过滤器及其变体

我们比较了标准布隆过滤器及其支持删除或更好查找性能的变体，如表 1 所总结。这些数据结构在第 7 节中进行了实验评估。布谷鸟过滤器在空间效率和性能上优于这些数据结构。

---

标准布隆过滤器 [3] 提供了一种紧凑的集合表示，支持两种操作：插入和查找。布隆过滤器允许可调的误报率 $\epsilon$，因此查询返回的结果要么是“肯定不存在”（无错误），要么是“可能存在”（有 $\epsilon$ 的概率错误）。$\epsilon$ 越低，过滤器所需的空间越多。

---

布隆过滤器由 $k$ 个哈希函数和一个初始所有位设置为“0”的位数组组成。要插入一个项，它通过 $k$ 个哈希函数将该项哈希到位数组中的 $k$ 个位置，然后将这 $k$ 个位设置为“1”。查找操作类似，但它读取数组中对应的 $k$ 个位：如果所有位都被设置，查询返回 true；否则返回 false。布隆过滤器不支持删除。

---

布隆过滤器可以非常节省空间，但并非最优 [20]。对于误报率 $\epsilon$，空间优化的布隆过滤器使用 $k=\log _{2}(1 / \epsilon)$ 个哈希函数。这样的布隆过滤器可以使用 $1.44 \log _{2}(1 / \epsilon)$ 位来存储每个项，这仅取决于 $\epsilon$，而与项的大小或总项数无关。信息论最小值要求每个项使用 $\log _{2}(1 / \epsilon)$ 位，因此空间优化的布隆过滤器比信息论下界多出 $44\%$ 的空间开销。

---

对于静态集合，通过使用指纹（长度为 $\lceil 1 / \epsilon\rceil$ 位）和完美哈希表 [6]，基本上可以实现信息论最优。为了高效处理删除操作，我们用精心设计的布谷鸟哈希表替代了完美哈希函数。

---

计数布隆过滤器 [12] 扩展了布隆过滤器以支持删除操作。计数布隆过滤器使用计数器数组替代位数组。插入操作会递增 $k$ 个计数器的值，而不是简单地设置 $k$ 个位，查找操作则检查所需的每个计数器是否非零。删除操作会递减这 $k$ 个计数器的值。为了防止算术溢出（即递增已达到最大可能值的计数器），数组中的每个计数器必须足够大以保留布隆过滤器的特性。在实践中，每个计数器由 4 位或更多位组成，因此计数布隆过滤器比标准布隆过滤器多需要 $4 \times$ 的空间。（可以通过引入辅助哈希表结构来管理溢出的计数器以减少空间，但这会增加复杂性。）

---

分块布隆过滤器 [22] 不支持删除，但在查找时提供了更好的空间局部性。分块布隆过滤器由多个小型布隆过滤器组成，每个小型布隆过滤器适合放入一个 CPU 缓存行中。每个项仅存储在这些小型布隆过滤器中的一个，由哈希分区决定。因此，每次查询最多导致一次缓存未命中以加载该小型布隆过滤器，从而显著提高了性能。缺点是，由于小型布隆过滤器数组中的负载不均衡，误报率会更高。

---

$d$-left 计数布隆过滤器 [5] 与我们在此使用的方法类似。使用 $d$-left 哈希 [19] 的哈希表存储项的指纹。这些过滤器通过删除指纹来删除项。与计数布隆过滤器相比，它们减少了 $50\%$ 的空间成本，通常需要比空间优化的不可删除布隆过滤器多 $1.5-2 \times$ 的空间。如我们所示，布谷鸟过滤器比 $d$-left 计数布隆过滤器具有更好的空间效率，并且具有其他优势，包括简单性。

---

商过滤器 [2] 也是存储指纹以支持删除操作的紧凑哈希表。商过滤器使用类似于线性探测的技术来定位指纹，从而提供了更好的空间局部性。然而，它们需要额外的元数据来编码每个条目，这比可比的标准布隆过滤器多需要 $10 \sim 25\%$ 的空间。此外，它的所有操作必须在到达目标项之前解码一系列表条目，并且哈希表填充得越多，这些序列就越长。因此，当哈希表的占用率超过 $75\%$ 时，其性能会显著下降。

---

其他变体：为了改进布隆过滤器，已经提出了其他变体，旨在优化空间和/或性能。RankIndexed Hashing [14] 构建了线性链式哈希表来存储压缩的指纹。虽然与 $d$-left 计数布隆过滤器类似且在某些方面更节省空间，但更新减少链式成本的内部索引非常昂贵，使其在动态环境中吸引力较低。Putze 等人提出了两种布隆过滤器的变体 [22]。一种是前面讨论过的分块布隆过滤器；另一种称为 Golomb 压缩序列，它将所有项的指纹存储在排序列表中。其空间接近最优，但该数据结构是静态的，并且需要非恒定的查找时间来解码编码序列。因此，本文未将其与其他过滤器一起评估。Pagh 等人提出了一种基于 Cleary [8] 的渐近空间最优数据结构 [20]。然而，这种数据结构比其替代方案复杂得多，似乎不适合高性能实现。相比之下，布谷鸟过滤器易于实现。

### 2.2 布谷鸟哈希表

布谷鸟哈希基础：基本的布谷鸟哈希表 [21] 由一个桶数组组成，其中每个项有两个候选桶，由哈希函数 $h_{1}(x)$ 和 $h_{2}(x)$ 确定。查找过程检查这两个桶，看是否包含该项。图 1(a) 展示了将新项 $x$ 插入到包含 8 个桶的哈希表中的示例，其中 $x$ 可以放置在桶 2 或桶 6 中。如果 $x$ 的两个桶中有一个为空，则算法将 $x$ 插入到该空闲桶中，插入完成。如果两个桶都没有空间，如本例所示，则该项选择其中一个候选桶（例如桶 6），踢出现有项（在本例中为“a”），并将该被踢出的项重新插入到其自己的备用位置。在我们的示例中，踢出“a”会触发另一次重新定位，将现有项“c”从桶 4 踢到桶 1。此过程可能会重复，直到找到空闲桶，如图 1(b) 所示，或者直到达到最大位移次数（例如，在我们的实现中为 500 次）。如果未找到空闲桶，则认为该哈希表太满而无法插入。尽管布谷鸟哈希可能会执行一系列位移，但其摊平插入时间为 $O(1)$。

---

布谷鸟哈希通过插入新项时优化早期的项放置决策，确保了高空间占用率。大多数布谷鸟哈希的实际实现扩展了上述基本描述，使用可容纳多个项的桶，如 [10] 中所建议。假设所有哈希函数完全随机，使用 $k$ 个哈希函数和大小为 $b$ 的桶时，最大可能负载已被分析 [13]。通过适当配置布谷鸟哈希表参数（在第 5 节中探讨），表空间可以以高概率填充到 $95\%$。

---

使用布谷鸟哈希进行集合成员测试：最近，标准布谷鸟哈希表已被用于在少数应用中提供集合成员信息。为了支持事务内存，Sanchez 等人提出将每个事务的内存地址读/写集存储在布谷鸟哈希表中，并在表满时将其转换为布隆过滤器 [23]。他们的设计使用了标准布谷鸟哈希表，因此需要比布谷鸟过滤器更多的空间。我们之前在构建高速和内存高效的键值存储 [17, 11] 以及基于软件的以太网交换机 [26] 中的研究，都应用了布谷鸟哈希表作为内部数据结构。这些工作受到一种称为部分键布谷鸟哈希的优化的启发，并专注于通过该优化提高哈希表性能。然而，如本文所示，该技术还启发了构建布隆过滤器替代品的新方法，这一方法此前尚未被研究。因此，本文也应用了部分键布谷鸟哈希，但更重要的是，它深入分析了使用该技术专门服务于集合成员测试（而不是键值查询），并进一步比较了布谷鸟过滤器与其他集合成员数据结构的性能。

---

布谷鸟过滤器的挑战：为了使布谷鸟过滤器高度空间高效，我们使用多路关联布谷鸟哈希表来提供高速查找和高表占用率（例如，$95\%$ 的哈希表槽被填充）；为了进一步减少哈希表大小，每个项在插入哈希表之前首先被哈希为固定大小的指纹。应用该数据结构的挑战在于重新设计插入过程并仔细配置哈希表，以最小化每个项的空间使用：

- 首先，仅在哈希表中存储指纹会阻止使用标准布谷鸟哈希方法插入项。因为在布谷鸟哈希中，插入算法必须能够将现有指纹重新定位到其备用位置。一种空间效率低但直接的解决方案是完整存储每个插入的项（可能在表外部）；给定原始项（“键”），计算其备用位置很容易。相比之下，布谷鸟过滤器使用部分键布谷鸟哈希，仅基于指纹找到项的备用位置（第 3 节）。
- 其次，布谷鸟过滤器将每个项与哈希表中的多个可能位置关联。这种存储项的灵活性提高了表占用率，但在每次查找时探测更多可能位置时保持相同的误报率需要更长的指纹，从而占用更多空间。在第 5 节中，我们提出了优化表占用率与其大小之间平衡的分析，以最小化每个项的平均空间成本。

## 3. 布谷鸟过滤器算法

在本文中，用于布谷鸟过滤器的布谷鸟哈希表的基本单位称为条目（entry）。每个条目存储一个指纹。哈希表由一个桶数组组成，每个桶可以包含多个条目。

---

本节描述了布谷鸟过滤器如何执行插入（Insert）、查找（Lookup）和删除（Delete）操作。第 3.1 节介绍了部分键布谷鸟哈希（partial-key cuckoo hashing），这是标准布谷鸟哈希的一种变体，使布谷鸟过滤器能够动态插入新项。该技术首次在之前的工作 [11] 中引入，但当时的背景是提高存储完整键的常规布谷鸟哈希表的查找和插入性能。相比之下，本文重点在于优化和分析仅使用指纹的部分键布谷鸟哈希的空间效率，以使布谷鸟过滤器在空间上比布隆过滤器更具竞争力甚至更紧凑。

### 3.1 插入

如前所述，使用标准布谷鸟哈希时，将新项插入现有哈希表需要某种方式访问原始项，以确定在需要时为新项腾出空间时将其重新定位到哪里（第 2.2 节）。然而，布谷鸟过滤器仅存储指纹，因此无法恢复和重新哈希原始键以找到其备用位置。为了克服这一限制，我们利用了一种称为部分键布谷鸟哈希的技术，基于指纹推导出项的备用位置。对于项 $x$，我们的哈希方案计算两个候选桶的索引如下：

$$
\begin{align*}
& h_{1}(x)=\operatorname{hash}(x) \\
& h_{2}(x)=h_{1}(x) \oplus \operatorname{hash}(x \text { 的指纹 }) . \tag{1}
\end{align*}
$$

---

公式 (1) 中的异或操作确保了一个重要特性：$h_{1}(x)$ 也可以从 $h_{2}(x)$ 和指纹使用相同的公式计算出来。换句话说，要替换最初在桶 $i$ 中的键（无论 $i$ 是 $h_{1}(x)$ 还是 $h_{2}(x)$），我们可以直接从当前桶索引 $i$ 和存储在该桶中的指纹计算其备用桶 $j$：
$$
\begin{equation*}
j=i \oplus \text { hash(指纹). } \tag{2}
\end{equation*}
$$

因此，插入操作仅使用表中的信息，而无需检索原始项 $x$。

---

此外，在指纹与当前桶索引进行异或操作之前，先对指纹进行哈希处理，以帮助将项均匀分布在表中。如果备用位置是通过“$i \oplus$ 指纹”计算的，而没有对指纹进行哈希处理，那么当指纹的大小相对于表大小较小时，从附近桶中踢出的项会在表中彼此靠近。例如，使用 8 位指纹时，从桶 $i$ 中踢出的项将被放置在距离桶 $i$ 最多 256 个桶的位置，因为异或操作会改变桶索引的低八位，而高位不会改变。对指纹进行哈希处理确保这些项可以重新定位到哈希表中完全不同的区域，从而减少哈希冲突并提高表的利用率。

---

使用部分键布谷鸟哈希，布谷鸟过滤器通过算法 1 所示的过程动态添加新项。由于这些指纹可能比 $h_{1}$ 或 $h_{2}$ 的大小短得多，因此会产生两个后果。首先，根据公式 (1) 计算的不同 $\left(h_{1}, h_{2}\right)$ 选择的总数可能远小于使用完美哈希推导 $h_{1}$ 和 $h_{2}$ 的标准布谷鸟哈希。这可能会导致更多的冲突，特别是之前对布谷鸟哈希的分析（如 [10, 13]）不再适用。部分键布谷鸟哈希的完整分析仍然是一个开放问题（超出了本文的范围）；在第 4 节中，我们详细讨论了这一问题，并探讨了如何在实际工作负载中实现高占用率。

---

其次，插入两个具有相同指纹的不同项 $x$ 和 $y$ 是可以的；同一个指纹可能会在一个桶中出现多次。然而，布谷鸟过滤器不适合插入同一项超过 $2 b$ 次的应用（$b$ 是桶的大小），因为该重复项的两个桶会变得过载。针对这种情况有几种解决方案。首先，如果表不需要支持删除，那么这个问题不会出现，因为每个指纹只需存储一个副本。其次，可以在一定程度上增加空间开销，为桶关联计数器，并适当地递增/递减它们。最后，如果原始键存储在某个地方（可能在较慢的外部存储中），可以查询该记录以完全防止重复插入，但代价是如果表中已经存在与桶和指纹匹配的（误报）条目，插入速度会减慢。类似的要求也适用于传统和 $d$-left 计数布隆过滤器。

### 3.2 查找

布谷鸟过滤器的查找过程非常简单，如算法 2 所示。给定一个项 $x$，算法首先根据公式 (1) 计算 $x$ 的指纹和两个候选桶。然后读取这两个桶：如果任何一个桶中的现有指纹匹配，布谷鸟过滤器返回 true，否则返回 false。请注意，只要桶溢出从未发生，这就能确保没有漏报。

### 3.3 删除

标准布隆过滤器无法删除项，因此删除单个项需要重建整个过滤器，而计数布隆过滤器则需要显著更多的空间。布谷鸟过滤器类似于计数布隆过滤器，可以通过从哈希表中删除相应的指纹来删除插入的项。其他具有类似删除过程的过滤器比布谷鸟过滤器更复杂。例如，$d$-left 计数布隆过滤器必须使用额外的计数器来防止指纹碰撞时的“误删”问题 ${ }^{1}$，而商过滤器必须移动一系列指纹以填充删除后的“空”条目并维护其“桶结构”。${ }^{2}$

1. $d$-left 计数布隆过滤器的简单实现存在“误删”问题。$d$-left 计数布隆过滤器将每个项映射到 $d$ 个候选桶，每个桶来自表的一个分区，并将指纹存储在其 $d$ 个桶之一中。如果两个不同的项共享且仅共享一个桶，并且它们具有相同的指纹（当指纹较小时很可能发生这种情况），则直接从该特定桶中删除指纹可能会导致错误的项被删除。为了解决这个问题，$d$-left 计数布隆过滤器在每个表条目中使用额外的计数器以及额外的间接寻址 [5]。
2. 在商过滤器中，所有具有相同商（即最高 $q$ 位）的指纹必须根据其数值顺序存储在连续的条目中。因此，从一组指纹中删除一个指纹必须将所有指纹在空缺之后的位置向前移动一个槽，并修改它们的元数据位。

---

布谷鸟过滤器的删除过程如算法 3 所示，要简单得多。它检查给定项的两个候选桶；如果任何桶中的指纹匹配，则从该桶中删除该匹配指纹的一个副本。

---

删除操作不必在删除项后清理条目。它还避免了当两个项共享一个候选桶并且具有相同指纹时的“误删”问题。例如，如果项 $x$ 和 $y$ 都位于桶 $i_{1}$ 中并且指纹 $f$ 发生碰撞，部分键布谷鸟哈希确保它们也可以位于桶 $i_{2}$ 中，因为 $i_{2}=i_{1} \oplus \operatorname{hash}(f)$。当删除 $x$ 时，删除过程移除的是插入 $x$ 还是 $y$ 时添加的 $f$ 副本并不重要。删除 $x$ 后，$y$ 仍然被视为集合成员，因为桶 $i_{1}$ 和 $i_{2}$ 中仍留有相应的指纹。这的一个重要后果是，删除后过滤器的误报行为保持不变。（在上面的例子中，根据定义，$y$ 在表中会导致对 $x$ 的查找产生误报：它们共享相同的桶和指纹。）这是近似集合成员数据结构的预期误报行为，其概率仍然以 $\epsilon$ 为界。

---

需要注意的是，为了安全地删除一个项 $x$，它必须之前被插入过。否则，删除一个未插入的项可能会无意中移除一个恰好共享相同指纹的真实的不同项。这一要求也适用于所有其他支持删除的过滤器。

## 4. 渐进行为

在这里，我们展示了使用部分键布谷鸟哈希在布谷鸟过滤器中存储指纹会导致指纹大小的下限随着过滤器大小的增加而缓慢增长。这与其它方法（例如之前讨论的用于静态布隆过滤器的指纹和完美哈希）形成对比，在那些方法中，指纹大小仅取决于所需的误报概率。虽然这看起来像是一个缺点，但在实践中，这种影响似乎并不重要。根据经验，当每个桶容纳四个 6 位或更大的指纹时，包含多达 40 亿个项的过滤器可以有效地以 $95\%$ 的负载填充其哈希表。

我们在本节和下一节分析中使用的符号是：
$$
\begin{array}{ll}
\epsilon & \text { 目标误报率 } \\
f & \text { 指纹长度（以位为单位） } \\
\alpha & \text { 负载因子 }(0 \leq \alpha \leq 1) \\
b & \text { 每个桶的条目数 } \\
m & \text { 桶的数量 } \\
n & \text { 项的数量 } \\
C & \text { 每个项的平均位数 }
\end{array}
$$

---

最小指纹大小：我们提出的部分键布谷鸟哈希基于项的当前位置和指纹推导出其备用桶（第 3 节）。因此，每个项的候选桶并不是独立的。例如，假设一个项可以放置在桶 $i_{1}$ 或 $i_{2}$ 中。根据公式 (1)，当使用 $f$ 位指纹时，$i_{2}$ 的可能值最多为 $2^{f}$。使用 1 字节指纹时，给定 $i_{1}$，$i_{2}$ 的不同可能值最多只有 $2^{f}=256$ 个。对于一个有 $m$ 个桶的表，当 $2^{f}<m$（或等效地 $f<\log _{2} m$ 位）时，$i_{2}$ 的选择只是整个哈希表所有 $m$ 个桶的一个子集。

---

直观地说，如果指纹足够长，部分键布谷鸟哈希仍然可以很好地近似于标准布谷鸟哈希；然而，如果哈希表非常大并且存储相对较短的指纹，由于哈希冲突，插入失败的概率会增加，这可能会降低表的占用率。当布谷鸟过滤器针对大量项但仅需要适度低的误报率时，可能会出现这种情况。接下来，我们通过分析确定插入失败概率的下限。

---

首先，我们推导出一组 $q$ 个项在同一两个桶中发生碰撞的概率。假设第一个项 $x$ 的第一个桶是 $i_{1}$，指纹为 $t_{x}$。如果其他 $q-1$ 个项与项 $x$ 具有相同的两个桶，它们必须 ${ }^{3}$ (1) 具有相同的指纹 $t_{x}$，其概率为 $1 / 2^{f}$；(2) 它们的第一个桶是 $i_{1}$ 或 $i_{1} \oplus h\left(t_{x}\right)$，其概率为 $2 / \mathrm{m}$。因此，这 $q$ 个项共享相同两个桶的概率为 $\left(2 / m \cdot 1 / 2^{f}\right)^{q-1}$。

---

现在考虑一个构造过程，将 $n$ 个随机项插入到一个有 $m=c n$ 个桶的空表中，其中 $c$ 是常数，桶大小为 $b$。每当有 $q=2 b+1$ 个项映射到同一两个桶时，插入就会失败。这个概率为失败提供了一个下限（并且，我们认为它主导了此构造过程的失败概率，尽管我们未证明这一点，也不需要证明以获得下限）。由于总共有 $\binom{n}{2 b+1}$ 种不同的 $2 b+1$ 个项的组合，构造过程中发生碰撞的 $2 b+1$ 个项的期望数量为

$$
\begin{equation*}
\binom{n}{2 b+1}\left(\frac{2}{2^{f} \cdot m}\right)^{2 b}=\binom{n}{2 b+1}\left(\frac{2}{2^{f} \cdot c n}\right)^{2 b}=\Omega\left(\frac{n}{4^{b f}}\right) \tag{3}
\end{equation*}
$$

---

我们得出结论，$4^{b f}$ 必须是 $\Omega(n)$ 以避免非平凡的失败概率，否则这个期望值为 $\Omega(1)$。因此，指纹大小必须为 $f=\Omega(\log n / b)$ 位。

这一结果似乎有些不幸，因为指纹所需的位数是 $\Omega(\log n)$；回想一下，布隆过滤器每个项使用一个常数（大约 $\ln (1 / \epsilon)$ 位）。因此，我们可能会担心这种方法的可扩展性。然而，正如我们接下来展示的那样，布谷鸟过滤器的实际应用被下限分母中的 $b$ 因子所拯救：只要我们使用合理大小的桶，指纹大小可以保持较小。

---

**实验评估**：图 2 展示了随着指纹大小 $f$、桶大小 $b$ 和表中桶数量 $m$ 的变化，部分键布谷鸟哈希实现的负载因子。在实验中，我们将指纹大小 $f$ 从 1 位调整到 20 位。随机 64 位键被插入到一个空过滤器中，直到单个插入在找到空条目之前重新定位现有指纹超过 500 次（我们的“满”条件），然后我们停止并测量实现的负载因子 $\alpha$。我们对 $m=2^{15}, 2^{20}, 2^{25}$ 和 $2^{30}$ 个桶的过滤器进行了十次实验，并测量了十次试验中的最小负载。由于测试机器的内存限制，我们没有使用更大的表。

---

如图 2 所示，在不同的配置中，$b=4$ 的过滤器可以填充到 $95\%$ 的占用率，而 $b=8$ 的过滤器可以填充到 $98\%$，前提是指纹足够长。之后，增加指纹大小在提高负载因子方面几乎没有回报（当然，它会降低误报率）。正如理论所暗示的那样，实现接近最优占用率所需的最小 $f$ 随着过滤器的增大而增加。此外，比较图 2(a) 和图 2(b)，当桶大小 $b$ 增大时，实现高占用率所需的最小 $f$ 减少，这也与理论一致。总体而言，短指纹似乎足以应对实际规模的项集。即使当 $b=4$ 且 $m=2^{30}$ 时，表可以包含多达 40 亿个项，一旦指纹超过 6 位，$\alpha$ 就接近使用两个完全独立的哈希函数在实验中获得的“最优负载因子”。

---

**洞察**：公式 (3) 推导的指纹大小的下限，以及图 2 所示的实验结果，为布谷鸟过滤器提供了重要的见解。虽然在理论上，布谷鸟过滤器的空间成本“比”布隆过滤器更差——$\Omega(\log n)$ 对比一个常数——但在这种情况下，常数项非常重要。对于布隆过滤器，实现 $\epsilon=1\%$ 需要每个项大约 10 位，无论存储的是一千、一百万还是十亿个项。相比之下，布谷鸟过滤器需要更长的指纹以保持其哈希表的相同高空间效率，但相应地实现了更低的误报率。$\Omega(\log n)$ 位的指纹，正如理论所预测的那样，如果桶大小 $b$ 足够大，其增长是缓慢的。我们发现，在实际应用中，它可以被视为一个合理大小的常数用于实现。图 2 显示，对于目标为几十亿个项的布谷鸟过滤器，6 位指纹足以确保哈希表的非常高利用率。

---

作为一种启发式方法，部分键布谷鸟哈希非常高效，正如我们在第 7 节中进一步展示的那样。然而，关于该技术的几个理论问题仍待未来研究，包括证明插入新项的成本边界以及研究哈希函数需要多少独立性。

## 5. 空间优化

第 3 节中介绍的布谷鸟过滤器操作（插入、查找和删除）的基本算法与哈希表配置（例如，每个桶有多少条目）无关。然而，为布谷鸟过滤器选择合适的参数可以显著影响空间效率。本节重点通过参数选择和附加机制来优化布谷鸟过滤器的空间效率。

---

空间效率通过完整过滤器中每个项的平均位数来衡量，由表大小除以过滤器可以有效存储的总项数得出。回想一下，尽管哈希表的每个条目存储一个指纹，但并非所有条目都被占用：表中必须有一些空闲空间，否则在插入项时会出现失败。因此，每个项的实际存储成本高于指纹：如果每个指纹为 $f$ 位，且哈希表的负载因子为 $\alpha$，则每个项的摊余空间成本 $C$ 为

$$
\begin{equation*}
C=\frac{\text { 表大小 }}{\# \text { 项数 }}=\frac{f \cdot(\# \text { 条目数 })}{\alpha \cdot(\# \text { 条目数 })}=\frac{f}{\alpha} \quad \text { 位。 } \tag{4}
\end{equation*}
$$

正如我们将展示的，$f$ 和 $\alpha$ 都与桶大小 $b$ 相关。以下部分研究了如何通过选择最佳桶大小 $b$ 来（近似）最小化公式 (4)，给定目标误报率 $\epsilon$。

### 5.1 最佳桶大小

保持布谷鸟过滤器的总大小不变但改变桶大小会导致两个后果：

(1) 更大的桶提高了表占用率（即更高的 $b \rightarrow$ 更高的 $\alpha$）。当 $k=2$ 个哈希函数时，桶大小 $b=1$ 时负载因子 $\alpha$ 为 $50\%$（即哈希表直接映射），但使用桶大小 $b=2,4$ 或 8 时，负载因子分别增加到 $84\%, 95\%$ 或 $98\%$。

---

(2) 更大的桶需要更长的指纹以保持相同的误报率（即更高的 $b \rightarrow$ 更高的 $f$）。随着桶的增大，每次查找会检查更多的条目，因此发生指纹碰撞的概率更高。在查找不存在项的最坏情况下，查询必须探测两个桶，每个桶可以有 $b$ 个条目。（虽然这些桶可能并未全部填满，但我们在此分析它们被填满的最坏情况；这为我们提供了一个对 $95\%$ 满表的合理准确估计。）在每个条目中，查询与存储的指纹匹配并返回误报成功匹配的概率最多为 $1 / 2^{f}$。在进行 $2 b$ 次这样的比较后，指纹误报的总概率上限为
$$
\begin{equation*}
1-\left(1-1 / 2^{f}\right)^{2 b} \approx 2 b / 2^{f} \tag{5}
\end{equation*}
$$

这与桶大小 $b$ 成正比。为了保持目标误报率 $\epsilon$，过滤器确保 $2 b / 2^{f} \leq \epsilon$，因此所需的最小指纹大小约为：

$$
\begin{equation*}
f \geq\left\lceil\log _{2}(2 b / \epsilon)\right\rceil=\left\lceil\log _{2}(1 / \epsilon)+\log _{2}(2 b)\right\rceil \text { 位。 } \tag{6}
\end{equation*}
$$

---

空间成本的上限 正如我们所展示的，$f$ 和 $\alpha$ 都取决于桶大小 $b$。根据公式 (4)，平均空间成本 $C$ 的上限为：
$$
\begin{equation*}
C \leq\left\lceil\log _{2}(1 / \epsilon)+\log _{2}(2 b)\right\rceil / \alpha, \tag{7}
\end{equation*}
$$

其中 $\alpha$ 随 $b$ 增加。例如，当 $b=4$ 时，$1 / \alpha \approx 1.05$，公式 (7) 显示布谷鸟过滤器在渐进意义上（通过一个常数因子）优于布隆过滤器，后者每个项需要 $1.44 \log _{2}(1 / \epsilon)$ 位或更多。

---

最佳桶大小 $b$ 为了比较使用不同桶大小 $b$ 的空间效率，我们进行了实验，首先通过部分键布谷鸟哈希构建不同指纹大小的布谷鸟哈希表，并测量每个项的摊余空间成本及其实现的误报率。如图 3 所示，空间最优的桶大小取决于目标误报率 $\epsilon$：当 $\epsilon>0.002$ 时，每个桶两个条目比每个桶四个条目的结果略好；当 $\epsilon$ 降低到 $0.00001<\epsilon \leq 0.002$ 时，每个桶四个条目最小化空间。

---

总结来说，我们选择 (2,4)-布谷鸟过滤器（即每个项有两个候选桶，每个桶最多有四个指纹）作为默认配置，因为它在大多数实际应用 [6] 可能感兴趣的误报率范围内实现了最佳或接近最佳的空间效率。接下来，我们介绍一种技术，通过编码每个桶，进一步为 $b=4$ 的布谷鸟过滤器节省空间。

### 5.2 半排序桶以节省空间

本节描述了一种针对每个桶有 $b=4$ 个条目的布谷鸟过滤器的技术，可以为每个项节省一位。这种优化基于一个事实：桶内指纹的顺序不会影响查询结果。基于这一观察，我们可以通过首先对指纹进行排序，然后对排序后的指纹序列进行编码来压缩每个桶。这种方案类似于 [5] 中使用的“半排序桶”优化。

---

以下示例说明了压缩如何节省空间。假设每个桶包含 $b=4$ 个指纹，每个指纹为 $f=4$ 位（更一般的情况将在后面讨论）。未压缩的桶占用 $4 \times 4=16$ 位。然而，如果我们对存储在该桶中的四个 4 位指纹进行排序（空条目被视为存储值为“0”的指纹），则总共有 3876 种可能的结果（允许重复的独特组合数）。如果我们预先计算并将这 3876 种可能的桶值存储在一个额外的表中，并用一个索引替换原始桶指向这个预先计算的表，那么每个原始桶可以用一个 12 位索引表示（$2^{12}=4096>3876$），而不是 16 位，为每个指纹节省 1 位。${ }^{4}$

- 如果布谷鸟过滤器不需要支持删除，那么它可以忽略指纹列表中的重复条目，从而有可能为每个条目节省额外的几分之一位。

---

需要注意的是，这种基于排列的编码（即索引所有可能的结果）需要额外的编码/解码表，并且在每次查找时需要进行间接访问。因此，为了实现高查找性能，重要的是使编码/解码表足够小以适合缓存。因此，我们的“半排序”优化仅适用于每个桶有四个条目的表。此外，当指纹大于四位时，仅对每个指纹的四个最高有效位进行编码；其余部分直接单独存储。

## 6. 与布隆过滤器的比较

我们使用表 2 中所示的指标以及几个额外因素来比较布隆过滤器和布谷鸟过滤器。

**空间效率**：表 2 比较了空间优化的布隆过滤器与带和不带半排序的布谷鸟过滤器。图 4 进一步展示了当 $\epsilon$ 从 $0.001\%$ 到 $10\%$ 变化时，这些方案表示一个项所需的位数。信息理论下界要求每个项使用 $\log _{2}(1 / \epsilon)$ 位，而最优布隆过滤器每个项使用 $1.44 \log _{2}(1 / \epsilon)$ 位，具有 $44\%$ 的开销。因此，当 $\epsilon<3\%$ 时，带半排序的布谷鸟过滤器比布隆过滤器更节省空间。

---

**内存访问次数**：对于具有 $k$ 个哈希函数的布隆过滤器，一个正向查询必须从位数组中读取 $k$ 位。对于需要 $k=\log _{2}(1 / \epsilon)$ 的空间优化布隆过滤器，随着 $\epsilon$ 变小，正向查询必须探测更多的位，并且在读取每个位时更可能发生缓存行未命中。例如，当 $\epsilon=25\%$ 时，$k=2$，但当 $\epsilon=1\%$ 时，$k=7$，这在实际中更为常见。对于空间优化的布隆过滤器，一个负向查询在返回之前平均读取两位，因为一半的位被设置。对于布谷鸟过滤器，任何查询（无论是正向还是负向）总是读取固定数量的桶，导致（最多）两次缓存行未命中。

---

**值关联**：布谷鸟过滤器可以扩展为还为每个匹配的指纹返回一个关联值（存储在过滤器外部）。布谷鸟过滤器的这一特性提供了一种近似的表查找机制，它为每个存在的项平均返回 $1+\epsilon$ 个值（由于误报命中，它可能匹配多个指纹），并为每个不存在的项平均返回 $\epsilon$ 个值。标准布隆过滤器不提供此功能。尽管像 Bloomier 过滤器这样的变体可以推广布隆过滤器以表示函数，但这些结构比布谷鸟过滤器更复杂且需要更多空间 [7]。

---

**最大容量**：布谷鸟过滤器有一个负载阈值。在达到最大可行负载因子后，插入操作失败的概率非平凡且逐渐增加，因此必须扩展哈希表以存储更多项。相比之下，可以继续向布隆过滤器中插入新项，但代价是误报率增加。为了保持相同的目标误报率，布隆过滤器也必须扩展。

---

**有限重复项**：如果布谷鸟过滤器支持删除操作，它必须存储相同项的多个副本。插入同一个项 $k b+1$ 次将导致插入失败。这与计数布隆过滤器类似，其中重复插入会导致计数器溢出。然而，向布隆过滤器或不可删除的布谷鸟过滤器中多次插入相同项没有影响。

## 7. 评估

我们的实现 ${ }^{5}$ 包括大约 500 行 $\mathrm{C}++$ 代码用于标准布谷鸟过滤器，以及 500 行代码用于支持第 5.2 节中介绍的“半排序”优化。在下文中，我们将基本布谷鸟过滤器称为“CF”，将带半排序的布谷鸟过滤器称为“ss-CF”。除了布谷鸟过滤器外，我们还实现了其他四种过滤器进行比较：

- **标准布隆过滤器（BF）**[3]：我们评估标准布隆过滤器作为基线。在我们所有的实验中，哈希函数的数量 $k$ 根据过滤器大小和总项数配置为以实现最低误报率。此外，应用了一种性能优化，通过减少哈希次数来加速查找和插入 [16]。每次插入或查找仅需要两个哈希函数 $h_{1}(x)$ 和 $h_{2}(x)$，然后使用这两个哈希函数以 $g_{i}(x)=h_{1}(x)+i \cdot h_{2}(x)$ 的形式模拟额外的 $k-2$ 个哈希函数。

- **分块布隆过滤器（blk-BF）**[22]：每个过滤器由一组块组成，每个块是一个小型布隆过滤器。每个块的大小为 64 字节，以匹配我们测试平台中的 CPU 缓存行。对于每个小型布隆过滤器，我们也应用了与标准布隆过滤器相同的模拟多个哈希函数的优化。
- **商过滤器（QF）**[2]：我们评估了我们自己实现的商过滤器 ${ }^{6}$。该过滤器为每个项存储三个额外的位作为元数据，以帮助定位项。由于商过滤器的性能随着负载增加而下降，我们将最大负载因子设置为 $90\%$，如 [2] 中评估的那样。
- **$d$-left 计数布隆过滤器（dl-CBF）**[5]：该过滤器配置为具有 $d=4$ 个哈希表。所有哈希表具有相同数量的桶；每个桶有四个条目。

---

我们强调，标准和分块布隆过滤器不支持删除操作，因此仅作为基线进行比较。

**实验设置**：所有要插入的项都是预生成的 64 位随机数生成器生成的整数。我们没有消除重复项，因为重复的概率非常小。

在每次查询中，所有过滤器首先使用 CityHash [1] 生成项的 64 位哈希值。然后，每个过滤器根据需要对这些 64 位进行分区。例如，布隆过滤器将高 32 位和低 32 位分别视为前两个独立哈希值，然后使用这两个 32 位值计算其他 $k-2$ 个哈希值。计算 64 位哈希的时间（在我们的测试平台中每个项大约 20 纳秒）已包含在我们的测量中。所有实验均在一台配备两个 Intel Xeon 处理器（L5640@2.27GHz，12MB L3 缓存）和 32 GB DRAM 的机器上进行。

---

**指标**：为了全面了解不同过滤器在功能、空间和性能之间如何实现权衡，我们通过以下指标比较上述过滤器：

- **空间效率**：通过过滤器大小（以位为单位）除以完整过滤器包含的项数来衡量。
- **实现的误报率**：通过使用不存在的项查询过滤器并统计返回的正值比例来衡量。
- **构建速率**：通过完整过滤器包含的项数除以从空状态构建该完整过滤器所需的时间来衡量。
- **查找、插入和删除吞吐量**：通过过滤器每秒可以执行的平均操作次数来衡量。该值可能取决于工作负载和过滤器的占用率。

### 7.1 实现的误报率

我们首先评估空间效率和误报率。在每次运行中，所有过滤器都配置为相同的大小（192 MB）。布隆过滤器配置为使用九个哈希函数，这可以在每个项 13 位的情况下最小化误报率。对于布谷鸟过滤器，它们的哈希表有 $m=2^{25}$ 个桶，每个桶由四个 12 位条目组成。$d$-left 计数布隆过滤器具有相同数量的哈希表条目，但分为 $d=4$ 个分区。商过滤器也有 $2^{27}$ 个条目，每个条目存储 3 位元数据和 9 位余数。

---

每个过滤器最初为空，然后插入项，直到过滤器出现插入失败（对于 CF 和 dl-CBF），或达到目标容量限制（对于 BF、blk-BF 和 QF）。不同过滤器的构建速率和误报率如表 3 所示。

---

在所有过滤器中，ss-CF 实现了最低的误报率。使用大致相同的空间（12.60 位/项），启用半排序可以为每个项的指纹多编码一位，从而将误报率从 $0.19\%$ 降低到 $0.09\%$。另一方面，半排序在访问每个桶时需要编码和解码，因此构建速率从每秒 5.00 百万项降低到 3.13 百万项。

---

BF 和 blk-BF 都使用每个项 13.00 位和 $k=9$ 个哈希函数，但分块过滤器的误报率比 BF 高 $2 \times$，比最佳 CF 高 $4 \times$。这种差异是因为 blk-BF 通过哈希将每个项分配到一个块，不平衡的映射会创建“热”块，这些块服务的项比平均水平多，以及“冷”块，这些块的利用率较低。不幸的是，即使使用强哈希函数，这种不平衡的分配也会在块之间发生 [18]，这会增加整体误报率。另一方面，由于任何查询都在单个缓存行中操作，blk-BF 实现了最高的构建速率。

---

QF 每个项使用的位数比 BF 和 CF 多，实现了第二低的误报率。由于编码和解码每个桶的成本，其构建速率是最低的。

最后，dl-CBF 在表大约 $78\%$ 满时出现插入失败并停止构建，因此存储的项少得多。其实现的误报率比其他过滤器差得多，因为每次查找必须检查 16 个条目，因此哈希碰撞的概率更高。

### 7.2 查找性能

**不同工作负载** 我们接下来在过滤器填满后对查找性能进行基准测试。本节比较了不同工作负载下的查找吞吐量和延迟。工作负载的特征是正向查询（即表中的项）和负向查询（即不在表中的项）的比例，这可能会影响查找速度。我们将输入工作负载中正向查询的比例 $p$ 从 $0\%$（所有查询都是负向）变化到 $100\%$（所有查询都是正向）。

查找吞吐量的基准测试结果如图 5 所示。每个过滤器占用 192 MB，远大于我们测试平台中的 L3 缓存（20 MB）。

---

blk-BF 在所有查询都是负向时表现良好，因为每次查找在获取第一个“0”位后可以立即返回。然而，当更多查询是正向时，其性能下降，因为它必须读取额外的位作为查找的一部分。BF 的吞吐量在 $p$ 增加时变化类似，但大约慢 4 MOPS。这是因为 BF 可能发生多次缓存未命中以完成一次查找，而分块版本始终在一个缓存行中操作，每次查找最多发生一次缓存未命中。

---

相比之下，CF 总是获取两个桶 ${ }^{7}$，因此在查询为 $100\%$ 正向和 $100\%$ 负向时实现了相同的高性能。当 $p=50\%$ 时，性能略有下降，因为 CPU 的分支预测最不准确（匹配或不匹配的概率恰好为 $1 / 2$）。通过半排序，CF 的吞吐量在正向查询比例增加时显示出类似的趋势，但由于读取每个桶时的额外解码开销，其性能较低。作为性能损失的回报，半排序版本将误报率降低到标准布谷鸟过滤器的一半。然而，当超过 $25\%$ 的查询是正向时，ss-CF 仍然优于 BF。

---

QF 在所有过滤器中表现最差。当 QF 填充到 $90\%$ 时，查找必须搜索一长串表条目，并解码每个条目以找到目标项。

dl-CBF 优于 ss-CF，但比 BF 慢 $30\%$。它在处理所有负向查询和所有正向查询时也保持大致相同的性能，因为每次查找只搜索固定数量的条目。

---

**不同占用率** 在本实验中，我们测量了这些过滤器在不同占用率下的查找吞吐量。我们将每个过滤器的负载因子 $\alpha$ 从 0（空）变化到其最大占用率。图 6 显示了所有查询都是负向（即查找不存在的项）和所有查询都是正向（即查找存在的项）时的平均瞬时查找吞吐量。

---

CF 和 ss-CF 的吞吐量在不同负载因子水平下基本稳定，无论是负向查询还是正向查询。这是因为即使插入更多项，读取和比较的条目总数仍然保持不变。

相比之下，QF 的吞吐量在负载增加时显著下降。随着负载因子的增加，该过滤器搜索目标项的条目链越来越长。

---

BF 和 blk-BF 在处理负向和正向查询时表现不同。对于正向查询，它们必须始终检查总共 $k$ 位，无论插入了多少项，因此提供恒定的查找吞吐量；而对于负向查询，当过滤器负载较低时，设置的位较少，查找在看到“0”时可以更早返回。

---

dl-CBF 的行为与 BF 不同。当所有查找都是负向时，它像 CF 一样确保恒定的吞吐量，因为无论过滤器包含多少项，都必须搜索来自四个桶的总共 16 个条目。对于正向查询，如果插入的项较少，查找可能在检查所有四个桶之前更早返回；然而，当 dl-CBF 填充到大约 $20\%$ 时，这种差异变得可以忽略不计。

### 7.3 插入性能

整体构建速度（基于完整过滤器包含的项总数和插入这些项的总时间测量）如表 3 所示。我们还研究了构建过程中瞬时插入吞吐量的变化。具体来说，我们测量了不同过滤器在不同负载因子水平下的插入吞吐量，如图 7 所示。

---

与图 6 所示的查找吞吐量不同，两种类型的 CF 在填充更多时插入吞吐量逐渐下降（尽管它们的整体构建速度仍然很高），而 BF 和 blk-BF 则确保几乎恒定的插入吞吐量。CF 可能需要在成功插入新项之前递归地移动一系列现有键，并且当负载因子增加时，这一过程变得更加昂贵。相比之下，两种布隆过滤器总是设置 $k$ 位，无论负载因子如何。

---

QF 的插入吞吐量也在下降，因为它必须在插入新项之前移动一系列项，并且当表填充更多时，这一序列变得更长。

dl-CBF 保持恒定的吞吐量。对于每次插入，它只需要在最多四个桶中找到一个空条目；如果找不到这样的条目，插入将停止，而不会像布谷鸟哈希那样重新定位现有项。这也是其最大负载因子不超过 $80\%$ 的原因。

### 7.4 删除性能

图 8 比较了支持删除的过滤器的删除性能。实验从初始完整的过滤器中删除键，直到其为空。CF 实现了最高的吞吐量。CF 和 ss-CF 在整个过程中提供稳定的性能。dl-CBF 在所有过滤器中表现第二好。QF 在接近满时最慢，但在接近空时比 ss-CF 更快。

---

**评估总结**：CF 确保在不同工作负载和不同占用率水平下具有高且稳定的查找性能。其插入吞吐量随着过滤器填充更多而下降，但整体构建速度仍然比其他过滤器（除了 blk-BF）更快。启用半排序使布谷鸟过滤器比空间优化的 BF 更节省空间。它还使查找、插入和删除变慢，但仍然比传统 BF 更快。

## 8. 结论

布谷鸟过滤器是一种用于近似集合成员查询的新数据结构，可用于许多以前使用布隆过滤器解决的网络问题。布谷鸟过滤器在以下三个方面改进了布隆过滤器：(1) 支持动态删除项；(2) 更好的查找性能；(3) 对于需要低误报率 $(\epsilon<3\%)$ 的应用，具有更好的空间效率。布谷鸟过滤器基于布谷鸟哈希存储一组项的指纹，从而实现高空间占用率。作为进一步的关键贡献，我们应用了部分键布谷鸟哈希，这使得布谷鸟过滤器通过仅基于存储的指纹进行重新定位而显著提高了效率。我们的配置探索表明，使用大小为 4 的桶的布谷鸟过滤器将在广泛的应用中表现良好，尽管布谷鸟过滤器的参数可以轻松调整以适应不同的应用需求。

---

虽然我们预计布谷鸟过滤器可能会有进一步的扩展和优化，并进一步推动其使用，但所描述的数据结构已经是一个快速高效的构建块，非常适合网络和分布式系统的实际需求。
